<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>02_类加载子系统</title>
    <url>/2021/04/15/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="1、内存结构的概述"><a href="#1、内存结构的概述" class="headerlink" title="1、内存结构的概述"></a>1、内存结构的概述</h1><span id="more"></span>
<p>开始讲之前，先看一下内存图</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg" alt="第02章_JVM架构-简图"> </p>
<p>下面是更加详细的图，有英文图，还有中文图</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E8%8B%B1.jpg" alt="第02章_JVM架构-英"> </p>
<p>中文图如下：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E4%B8%AD.jpg" alt="第02章_JVM架构-中"> </p>
<p>如果想自己写一个java虚拟机的话，主要考虑哪些结构？  类加载器 和 执行引擎</p>
<h1 id="2、类加载器与类的加载过程"><a href="#2、类加载器与类的加载过程" class="headerlink" title="2、类加载器与类的加载过程"></a>2、类加载器与类的加载过程</h1><h2 id="2-1、类加载子系统的作用"><a href="#2-1、类加载子系统的作用" class="headerlink" title="2.1、类加载子系统的作用"></a>2.1、类加载子系统的作用</h2><blockquote>
<p>1、类加载子系统负责从<strong>文件系统 **或者</strong>网络<strong>中加载class文件，class文件在文件的开头有</strong>特定的文件标识**。</p>
<p>2、ClassLoader只负责class文件的加载，至于它（指的是class文件）是否可以运行，则由<strong>执行引擎</strong>（Execution Engine）决定。</p>
<p>3、<strong>加载的类信息</strong>存放在一块称为<strong>方法区</strong>的内存空间中。除了类的信息外，方法区中还会存放<strong>运行时常量池信息</strong>，可能还包括字符串字面量和数字常量（这部分常量信息时class文件常量池部分的内存映射）。</p>
</blockquote>
<h2 id="2-2、类加载器ClassLoader角色"><a href="#2-2、类加载器ClassLoader角色" class="headerlink" title="2.2、类加载器ClassLoader角色"></a>2.2、类加载器ClassLoader角色</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405154241641.png" alt="image-20210405154241641"> </p>
<h2 id="2-3、类的加载过程"><a href="#2-3、类的加载过程" class="headerlink" title="2.3、类的加载过程"></a>2.3、类的加载过程</h2><p><strong>简略过程</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405154524267.png" alt="image-20210405154524267"> </p>
<p><strong>详细过程</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/%E7%AC%AC02%E7%AB%A0_%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.jpg" alt="第02章_类的加载过程"> </p>
<p><strong>加载</strong>：</p>
<blockquote>
<p>1、通过一个类的全限定名获取定义此类的二进制字节流</p>
<p>2、讲这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>3、<strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问接口</p>
</blockquote>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210406201208952.png" alt="image-20210406201208952"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405155623036.png" alt="image-20210405155623036"> </p>
<p><strong>链接</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405155954724.png" alt="image-20210405155954724"> </p>
<p><strong>初始化</strong>：</p>
<blockquote>
<p>1、<strong>初始化阶段就是执行类构造器方法<clinit>() 的过程</clinit></strong></p>
<p>2、此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并来的。</p>
<p>3、构造器方法中的指令按语句在源文件中出现的顺序执行</p>
<p>4、**<clinit>() 不同于类的构造器。**（关联：构造器是虚拟机视角下的<init>() ）</init></clinit></p>
<p>5、若该类有父类，JVM会保证子类的<clinit>()执行前，父类的已经执行完毕。</clinit></p>
<p>6、虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。</clinit></p>
</blockquote>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405192944395.png" alt="image-20210405192944395"> </p>
<h1 id="3、类加载器的分类"><a href="#3、类加载器的分类" class="headerlink" title="3、类加载器的分类"></a>3、类加载器的分类</h1><h2 id="3-1、概述"><a href="#3-1、概述" class="headerlink" title="3.1、概述"></a>3.1、概述</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405193156149.png" alt="image-20210405193156149"> </p>
<p>下图中，最上边的是引导类加载器，下边的扩展类加载器和系统类（应用程序类）加载器都是自定义加载器</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405193519650.png" alt="image-20210405193519650"> </p>
<p>这里面的四者的关系是包含的关系，并不是上下层的关系，也不是子父类继承的关系</p>
<p>对于用户自定义类来说：默认使用的是系统类加载器</p>
<p>String类使用的是引导类加载器进行加载。 Java的核心类库都是使用的引导类加载器进行加载的</p>
<p>引导类加载器是在程序中获取不到的（输出null），就因为它只用来加载核心类库，我们写的代码鸟都不鸟</p>
<p>下图是相关的程序实例：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405195942291.png" alt="image-20210405195942291"> </p>
<h2 id="3-2、虚拟机自带的加载器"><a href="#3-2、虚拟机自带的加载器" class="headerlink" title="3.2、虚拟机自带的加载器"></a>3.2、虚拟机自带的加载器</h2><h3 id="3-2-1、启动类加载器（引导类加载器，BootStrap-ClassLoader）"><a href="#3-2-1、启动类加载器（引导类加载器，BootStrap-ClassLoader）" class="headerlink" title="3.2.1、启动类加载器（引导类加载器，BootStrap ClassLoader）"></a>3.2.1、启动类加载器（引导类加载器，BootStrap ClassLoader）</h3><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405200707333.png" alt="image-20210405200707333"> </p>
<p>解释”加载拓展类和应用程序类加载器“：由上面的知识可知，拓展类加载器和应用程序类加载器是一个对象，这个对象就要对应着一个类就需要加载，这个类属于核心类库，所以也需要使用引导类加载器进行加载</p>
<h3 id="3-2-2、拓展类加载器（Extension-ClassLoader）"><a href="#3-2-2、拓展类加载器（Extension-ClassLoader）" class="headerlink" title="3.2.2、拓展类加载器（Extension ClassLoader）"></a>3.2.2、拓展类加载器（Extension ClassLoader）</h3><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405201820866.png" alt="image-20210405201820866"> </p>
<p>由第一条知：$符号是内部类的意思</p>
<p>注：这里的父类加载器不是Java中的继承关系，是指这个类是由哪个加载器加载进内存的</p>
<h3 id="3-2-3、应用程序类加载器（系统类加载器，App-ClassLoader）"><a href="#3-2-3、应用程序类加载器（系统类加载器，App-ClassLoader）" class="headerlink" title="3.2.3、应用程序类加载器（系统类加载器，App ClassLoader）"></a>3.2.3、应用程序类加载器（系统类加载器，App ClassLoader）</h3><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405202750163.png" alt="image-20210405202750163"> </p>
<p>有人说，这里的父类加载器可以改成上级加载器，意思是由上一层加载器加载；周志明书里说，类加载器之间的关系不是是靠继承关系实现的，而是靠组合关系实现的</p>
<p>相关程序示例：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405204232060.png" alt="image-20210405204232060"> </p>
<p>运行结果：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405204319220.png" alt="image-20210405204319220"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405204354540.png" alt="image-20210405204354540"> </p>
<h3 id="3-2-4、用户自定义类加载器（User-Defined-Class-Loader）"><a href="#3-2-4、用户自定义类加载器（User-Defined-Class-Loader）" class="headerlink" title="3.2.4、用户自定义类加载器（User Defined Class Loader）"></a>3.2.4、用户自定义类加载器（User Defined Class Loader）</h3><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405204904397.png" alt="image-20210405204904397"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405214114012.png" alt="image-20210405214114012"> </p>
<h1 id="4、ClassLoader的使用说明"><a href="#4、ClassLoader的使用说明" class="headerlink" title="4、ClassLoader的使用说明"></a>4、ClassLoader的使用说明</h1><p>ClassLoader类，是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405214547995.png" alt="image-20210405214547995"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405214731940.png" alt="image-20210405214731940"> </p>
<p>获取ClassLoader的途径</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405214818091.png" alt="image-20210405214818091"> </p>
<h1 id="5、双亲委派机制（重要）"><a href="#5、双亲委派机制（重要）" class="headerlink" title="5、双亲委派机制（重要）"></a>5、双亲委派机制（重要）</h1><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说，当需要使用该类的时候才会将它的class为见加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<strong>双亲委派模式</strong>，即把请求交由父类处理，他是一种任务委派模式。有人用通俗语言解释这个模式：<strong>我爸是李刚，有事找我爸</strong>。</p>
<p><strong>工作原理</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405220047876.png" alt="image-20210405220047876"> </p>
<p>注：这里不是继承。</p>
<p><strong>举例1</strong>：孙子、父亲、爷爷，互相让苹果</p>
<p><strong>举例2</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405221552015.png" alt="image-20210405221552015"> </p>
<p><strong>优势</strong>：</p>
<blockquote>
<p>1、避免类的重复加载</p>
<p>2、保护程序安全，防止核心API被随意篡改。例如，自定义类java.lang.String、自定义类java.lang.Sxll</p>
</blockquote>
<p><strong>沙箱安全机制：</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405221653866.png" alt="image-20210405221653866"> </p>
<h1 id="6、其他"><a href="#6、其他" class="headerlink" title="6、其他"></a>6、其他</h1><p>补充内容1：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405221927547.png" alt="image-20210405221927547"> </p>
<p>补充内容2：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405222123517.png" alt="image-20210405222123517"> </p>
<p>类的主动使用和被动使用：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/02_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/image-20210405222305101.png" alt="image-20210405222305101"> </p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>01_JVM与Java体系结构</title>
    <url>/2021/04/15/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="1、Java是一种跨平台的语言"><a href="#1、Java是一种跨平台的语言" class="headerlink" title="1、Java是一种跨平台的语言"></a>1、Java是一种跨平台的语言</h1><span id="more"></span>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_Java%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7.jpg" alt="第01章_Java语言的跨平台性"> </p>
<p><strong>注：</strong>一次编译，到处运行</p>
<h1 id="2、JVM是一种跨语言的平台"><a href="#2、JVM是一种跨语言的平台" class="headerlink" title="2、JVM是一种跨语言的平台"></a>2、JVM是一种跨语言的平台</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B9%B3%E5%8F%B0.jpg" alt="第01章_JVM跨语言的平台"> </p>
<p><strong>注：</strong>Java可能不是最强大的语言，但是JVM是相当强大的虚拟机</p>
<h1 id="3、字节码"><a href="#3、字节码" class="headerlink" title="3、字节码"></a>3、字节码</h1><p>平时说的Java字节码，是用Java语言编写的程序编译之后产生的字节码文件。</p>
<p>准确的说，任何能在jvm平台上运行的字节码文件格式都是一样的（任何一种编程语言，只要在编译出字节码文件的时候符合JVM规范）</p>
<p>Java平台上的多语言混合编程正在成为主流，通过特定领域的语言去解决特定领域的问题。</p>
<p>推动Java虚拟机 从“Java语言的虚拟机” 向 ”多语言虚拟机“ 的方向发展。</p>
<h1 id="4、如何真正搞懂JVM？"><a href="#4、如何真正搞懂JVM？" class="headerlink" title="4、如何真正搞懂JVM？"></a>4、如何真正搞懂JVM？</h1><p>Java虚拟机非常的复杂，要想真正理解他的工作原理，最好的方式就是<strong>自己写一个</strong>，嘿嘿嘿</p>
<p>难：如果按照JVM规范，写一个商用的虚拟机，是不可能一个人完成的</p>
<p>易：写一个小程序跑一下还是比较简单的</p>
<p><strong>注：</strong>推荐书籍 – – 《自己动手写Java虚拟机》</p>
<h1 id="5、虚拟机和Java虚拟机的区别"><a href="#5、虚拟机和Java虚拟机的区别" class="headerlink" title="5、虚拟机和Java虚拟机的区别"></a>5、虚拟机和Java虚拟机的区别</h1><p>虚拟机分为系统虚拟机和程序虚拟机：</p>
<p>系统虚拟机，例如VMware，用来模拟物理计算机；程序虚拟机，例如Java虚拟机，主要是用来专门执行单个程序而设计。</p>
<p>Java虚拟机，是二进制字节码文件的运行环境。ta的特点：1.一次编译，到处运行 2.自动内存管理 3.自动垃圾回收功能</p>
<h1 id="6、JVM的位置"><a href="#6、JVM的位置" class="headerlink" title="6、JVM的位置"></a>6、JVM的位置</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC01%E7%AB%A0_JVM%E6%89%80%E5%A4%84%E4%BD%8D%E7%BD%AE.jpg" alt="第01章_JVM所处位置"> </p>
<h1 id="7、JVM的整体结构"><a href="#7、JVM的整体结构" class="headerlink" title="7、JVM的整体结构"></a>7、JVM的整体结构</h1><p>接下的这个图很重要，重要到都得让你会画</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg" alt="第02章_JVM架构-简图"> </p>
<p>HotSpot VM是市面上高性能虚拟机的代表之一，采用的是解释器与即时编译器并存的架构，今天的JVM性能已经非常好了</p>
<p>方法区和堆是多线程共享的，虚拟机栈，程序计数器和本地方法栈是每个线程独有一份的。</p>
<h1 id="8、Java代码的执行流程"><a href="#8、Java代码的执行流程" class="headerlink" title="8、Java代码的执行流程"></a>8、Java代码的执行流程</h1><p>看图说话</p>
<p>前端编译器：将Java源码编译成字节码文件的编辑器</p>
<p>后端编译器：JIT编译器，将字节码指令编辑成机器指令，因为有些代码反复执行，所以对这种热点代码进行了缓存，以便重复使用</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210402213630668.png" alt="image-20210402213630668"> </p>
<h1 id="9、JVM的架构模型"><a href="#9、JVM的架构模型" class="headerlink" title="9、JVM的架构模型"></a>9、JVM的架构模型</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210402214845425.png" alt="image-20210402214845425"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210409100906566.png" alt="image-20210409100906566">  </p>
<p>注：详细的内容后边会详细的讲解</p>
<p>总结：</p>
<p><strong>由于跨平台的设计，Java的指令是根据栈来设计的。</strong>因为不同平台下的CPU架构不同，所以不能基于寄存器来设计。 优点是，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h1 id="10、JVM的生命周期"><a href="#10、JVM的生命周期" class="headerlink" title="10、JVM的生命周期"></a>10、JVM的生命周期</h1><p>1、虚拟机的启动：虚拟机的启动是通过<strong>引导类加载器</strong>（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的</p>
<p>2、虚拟机的执行：</p>
<blockquote>
<p>1、一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</p>
</blockquote>
<p>2、程序开始执行的时候他才运行，程序结束他就停止</p>
<blockquote>
<p>3、<strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</strong>。</p>
</blockquote>
<p>3、虚拟机的退出</p>
<p>如下的几种情况</p>
<blockquote>
<p>1、程序正常执行结束</p>
<p>2、程序在执行过程中遇到了异常或者错误而异常终止</p>
<p>3、由于操作系统出现错误而导致Java虚拟机进程终止</p>
<p>4、某线程调用Runtime类或者System类的exit方法，或者Runtime类的halt方法，并且Java安全管理器也允许这次的exit或halt调用</p>
<p>5、除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或者卸载 Java虚拟机的推出情况</p>
</blockquote>
<h1 id="11、JVM的发展历程"><a href="#11、JVM的发展历程" class="headerlink" title="11、JVM的发展历程"></a>11、JVM的发展历程</h1><p>1、SUN Classic VM 的介绍</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210403101529731.png" alt="image-20210403101529731"> </p>
<p>注：解释器相当于步行，执行很慢；JIT 执行很快，但是需要很长的启动时间，就像在等公交车，但是一旦等到了公交车，速度就会变得很快了。</p>
<p>2、EXact VM 的介绍</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210403101905999.png" alt="image-20210403101905999"> </p>
<p>3、SUN公司的 HotSpot VM</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210403105318598.png" alt="image-20210403105318598"> </p>
<p>4、BEA的 JRockit  VM</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210403105808397.png" alt="image-20210403105808397"> </p>
<p>5、IBM 的 J9 VM</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/01_JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20210403110134172.png" alt="image-20210403110134172"> </p>
<p>注：<strong>所有虚拟机的原则 — 一次编译，到处运行</strong>。</p>
<p>6、未来的新星 Graal VM</p>
<blockquote>
<p>1、2018年4月，Oracle Labs 公开了Graal VM，号称 ”Run Programs Faster Anywhere“，野心勃勃。与 1995年Java的 ”write once，run anywere“ 遥相呼应。</p>
<p>2、Graal VM 在HotSpot VM 的基础上增强而成的<strong>跨语言全栈虚拟机，可作为”任何语言“的运行平台使用。</strong>语言包括：Java、scale、groovy、kotlin；c、c++、JavaScript、Ruby、python、R等</p>
<p>3、支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p>
<p>4、工作原理是将这些语言的源代码或者源代码编译之后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM 提供的Truffle工具快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p>
<p>5、<strong>如果说HotSpot有一天真的被取代，Graal VM希望最大</strong>。但是Java的软件生态没有丝毫变化。</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>03_运行时数据区概述及线程</title>
    <url>/2021/04/15/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><span id="more"></span>
<h2 id="1-1、从这一节开始，就要进行运行时数据区的讲解"><a href="#1-1、从这一节开始，就要进行运行时数据区的讲解" class="headerlink" title="1.1、从这一节开始，就要进行运行时数据区的讲解"></a>1.1、从这一节开始，就要进行运行时数据区的讲解</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E7%AE%80%E5%9B%BE.jpg" alt="第02章_JVM架构-简图"> </p>
<p>下图是引入运行时数据区，“？”部分就是接下来的重点</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/%E7%AC%AC03%E7%AB%A0_%E5%BC%95%E5%85%A5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="第03章_引入运行时数据区"> </p>
<p>有趣的举例（康师傅真牛逼）</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20210406202232005.png" alt="image-20210406202232005"> </p>
<p>注解：后边桌子上摆的各种食材和各种刀具，可以看成时<strong>运行时数据区</strong>。厨师就可以看成是我们的<strong>执行引擎</strong>，利用运行时数据区进行一系列的操作，最后清理垃圾（运行时数据区的）</p>
<h2 id="1-2、内存的介绍"><a href="#1-2、内存的介绍" class="headerlink" title="1.2、内存的介绍"></a>1.2、内存的介绍</h2><p>内存时一种非常重要的系统资源，是硬盘和 CPU的 中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行的过程中的内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20210406203547414.png" alt="image-20210406203547414"> </p>
<p>阿里手册里的一张图：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20210406203627437.png" alt="image-20210406203627437"> </p>
<p>一个虚拟机对应着一个进程，进程里面可以有线程</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20210406204159150.png" alt="image-20210406204159150"> </p>
<p>方法去写成了堆外内存，暂时将永久代或者元空间看成是方法区的实现。至于代码缓存算不算是方法区中的，不用纠结，只需要知道代码缓存肯定不是堆空间的内容就行。</p>
<p>在整个JVM优化过程当中，针对线程里面的东西没有太多优化的问题。垃圾回收的95%的问题集中在堆区，5%集中在方法区。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/%E7%AC%AC03%E7%AB%A0_%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%92%8C%E7%A7%81%E6%9C%89%E7%9A%84%E7%BB%93%E6%9E%84.jpg" alt="第03章_线程共享和私有的结构"> </p>
<h2 id="1-3、关于线程间共享的说明"><a href="#1-3、关于线程间共享的说明" class="headerlink" title="1.3、关于线程间共享的说明"></a>1.3、关于线程间共享的说明</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20210406205329574.png" alt="image-20210406205329574"> </p>
<h1 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20210406210036386.png" alt="image-20210406210036386"> </p>
<p>JVM系统线程</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/03_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B/image-20210406210657716.png" alt="image-20210406210657716"> </p>
<p>后续在调优的部分还会详细的讲解</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>04_程序计数器（PC寄存器）</title>
    <url>/2021/04/15/04_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89/</url>
    <content><![CDATA[<h1 id="1、PC-Register介绍"><a href="#1、PC-Register介绍" class="headerlink" title="1、PC Register介绍"></a>1、PC Register介绍</h1><span id="more"></span>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/04_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89/image-20210406212158867.png" alt="image-20210406212158867"> </p>
<p><strong>作用</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/04_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89/image-20210406212426121.png" alt="image-20210406212426121"> </p>
<p><strong>介绍</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/04_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89/image-20210406214038007.png" alt="image-20210406214038007"> </p>
<p>这最后一条的意思是，JVM的PC寄存器是Java层面的内容，native是调用的本地方法，所以是不显示的未指定值。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/04_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89/image-20210406214841462.png" alt="image-20210406214841462"> </p>
<p>注：虚拟机栈不考虑垃圾回收，堆和方法区是由垃圾回收的；PC寄存器也不会内存溢出，其他的部分都有可能。</p>
<h1 id="2、举例说明"><a href="#2、举例说明" class="headerlink" title="2、举例说明"></a>2、举例说明</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/04_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89/image-20210406215703126.png" alt="image-20210406215703126"> </p>
<p>左边的数字是指令地址（或者叫偏移地址），这就是PC寄存器中存储的内容；右边的内容可以理解为操作指令</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/04_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89/image-20210406220603758.png" alt="image-20210406220603758"> </p>
<p>执行引擎从PC寄存器中存储的地址找到对应的指令，然后进行了转换为机器指令和操作局部变量表、操作数栈这两步骤。</p>
<h1 id="3、两个常见问题"><a href="#3、两个常见问题" class="headerlink" title="3、两个常见问题"></a>3、两个常见问题</h1><h2 id="3-1、第一个问题"><a href="#3-1、第一个问题" class="headerlink" title="3.1、第一个问题"></a>3.1、第一个问题</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/04_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89/image-20210406220852415.png" alt="image-20210406220852415"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/04_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89/%E7%AC%AC04%E7%AB%A0_PC%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt="第04章_PC寄存器"> </p>
<h2 id="3-2、第二个问题"><a href="#3-2、第二个问题" class="headerlink" title="3.2、第二个问题"></a>3.2、第二个问题</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/04_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89/image-20210406221159909.png" alt="image-20210406221159909"> </p>
<p><strong>CPU时间片</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/04_%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89/image-20210406221557214.png" alt="image-20210406221557214"> </p>
<p>并行：某个时间段所有时间内一起执行。</p>
<p>vs 串行：某个时间段内，挨着一个个排队来执行。</p>
<p>并发：某个时间段内一起执行，由于切换速度很快，所以看成是并行，但是在某个时间点只有一个在执行。</p>
<p>先了解一下，后边的垃圾回收还会讲。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>05_虚拟机栈</title>
    <url>/2021/04/15/05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
    <content><![CDATA[<h1 id="1、虚拟机栈概述"><a href="#1、虚拟机栈概述" class="headerlink" title="1、虚拟机栈概述"></a>1、虚拟机栈概述</h1><span id="more"></span>
<h2 id="1-1、虚拟机出现的背景"><a href="#1-1、虚拟机出现的背景" class="headerlink" title="1.1、虚拟机出现的背景"></a>1.1、虚拟机出现的背景</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20210407150650677.png" alt="image-20210407150650677"> </p>
<h2 id="1-2、初步印象"><a href="#1-2、初步印象" class="headerlink" title="1.2、初步印象"></a>1.2、初步印象</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20210407150826400.png" alt="image-20210407150826400"> </p>
<p>注：这样的理解是狭义的，不全面的。C++的内存结构主体上就是栈和堆，可能受其影响。实际上Java的划分更加的细致。</p>
<h2 id="1-3、内存中的栈和堆"><a href="#1-3、内存中的栈和堆" class="headerlink" title="1.3、内存中的栈和堆"></a>1.3、内存中的栈和堆</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20210407151244600.png" alt="image-20210407151244600"> </p>
<p>注：对象主要在堆中放，也不是所有的数据都放在堆中。比如方法内的局部变量（基本数据类型，如果是引用数据类型，栈空间知识存放了对象的引用）就放在栈中。</p>
<h2 id="1-4、举例说明"><a href="#1-4、举例说明" class="headerlink" title="1.4、举例说明"></a>1.4、举例说明</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20210407151751805.png" alt="image-20210407151751805"> </p>
<p>注：左边理解为栈，右边理解为堆。有一个直观的认识就行了。左边的上边看成是局部变量表，左边的下边看成是操作数栈（表达式栈）</p>
<h2 id="1-5、虚拟机的基本内容"><a href="#1-5、虚拟机的基本内容" class="headerlink" title="1.5、虚拟机的基本内容"></a>1.5、虚拟机的基本内容</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20210407153845256.png" alt="image-20210407153845256"> </p>
<p><strong>示意图</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20210407154118966.png" alt="image-20210407154118966"> </p>
<p>注：我们将栈顶的元素称为当前方法</p>
<p><strong>栈的特点（优点）</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20210407154353365.png" alt="image-20210407154353365"> </p>
<p>注：栈虽然不需要垃圾回收，但是可能会存在栈溢出或者内存溢出的情况</p>
<p><strong>面试：开发中你遇见过的异常有哪些？</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20210407155009454.png" alt="image-20210407155009454"> </p>
<p><strong>设置栈的内存大小</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/05_%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/image-20210407155716662.png" alt="image-20210407155716662"> </p>
<h1 id="2、栈的存储单位"><a href="#2、栈的存储单位" class="headerlink" title="2、栈的存储单位"></a>2、栈的存储单位</h1><h2 id="2-1栈中存储了什么？"><a href="#2-1栈中存储了什么？" class="headerlink" title="2.1栈中存储了什么？"></a>2.1栈中存储了什么？</h2><p><img src="/2021/04/15/05_虚拟机栈/image-20210407161329070.png" alt="image-20210407161329070"> </p>
<p>注：方法和栈帧是一一对应的关系，一个方法的执行，对应着一个栈帧的入栈；一个方法的结束，对应的栈帧就会出栈。栈帧中存放的数据就是方法执行所需要的内容。</p>
<p><strong>复习</strong>：OOP（面向对象编程）的基本单位是类和对象，类中的基本结构：field（属性、字段、域）、method</p>
<h2 id="2-2、栈的运行原理"><a href="#2-2、栈的运行原理" class="headerlink" title="2.2、栈的运行原理"></a>2.2、栈的运行原理</h2><p><img src="/2021/04/15/05_虚拟机栈/image-20210407162232205.png" alt="image-20210407162232205"> </p>
<p><strong>图示</strong>：</p>
<p><img src="/2021/04/15/05_虚拟机栈/%E7%AC%AC05%E7%AB%A0_%E6%96%B9%E6%B3%95%E4%B8%8E%E6%A0%88%E6%A1%A2.jpg" alt="第05章_方法与栈桢"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407163522766.png" alt="image-20210407163522766"> </p>
<p>注：此时的抛出异常是指的没有处理的异常，如果处理了异常，就是正常函数返回。方法执行中出现未捕获的异常，以抛出异常的方式结束。</p>
<h2 id="2-3、栈帧的内部结构"><a href="#2-3、栈帧的内部结构" class="headerlink" title="2.3、栈帧的内部结构"></a>2.3、栈帧的内部结构</h2><p><img src="/2021/04/15/05_虚拟机栈/image-20210407165008277.png" alt="image-20210407165008277"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/%E7%AC%AC05%E7%AB%A0_%E6%A0%88%E6%A1%A2%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.jpg" alt="第05章_栈桢内部结构"></p>
<h1 id="3、局部变量表（local-variable-table）"><a href="#3、局部变量表（local-variable-table）" class="headerlink" title="3、局部变量表（local variable table）"></a>3、局部变量表（local variable table）</h1><h2 id="3-1、相关概念"><a href="#3-1、相关概念" class="headerlink" title="3.1、相关概念"></a>3.1、相关概念</h2><p><img src="/2021/04/15/05_虚拟机栈/image-20210407194901011.png" alt="image-20210407194901011"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407200818043.png" alt="image-20210407200818043"> </p>
<h2 id="3-2、关于Slot的理解"><a href="#3-2、关于Slot的理解" class="headerlink" title="3.2、关于Slot的理解"></a>3.2、关于Slot的理解</h2><p><img src="/2021/04/15/05_虚拟机栈/image-20210407203207242.png" alt="image-20210407203207242"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407203448658.png" alt="image-20210407203448658"> </p>
<p>注：在静态方法中是不能够使用this的，因为在静态方法的局部变量表中是不存在对象引用this的。而在构造方法或者实例方法中，是存在该对象引用的，对象引用存在于该方法的局部变量表的首位，因此可以使用this的。</p>
<h2 id="3-3、Slot的重复利用"><a href="#3-3、Slot的重复利用" class="headerlink" title="3.3、Slot的重复利用"></a>3.3、Slot的重复利用</h2><p><img src="/2021/04/15/05_虚拟机栈/image-20210407205628011.png" alt="image-20210407205628011"> </p>
<h2 id="3-4、举例：静态变量与实例变量的对比"><a href="#3-4、举例：静态变量与实例变量的对比" class="headerlink" title="3.4、举例：静态变量与实例变量的对比"></a>3.4、举例：静态变量与实例变量的对比</h2><p><strong>变量的分类</strong>：</p>
<blockquote>
<p>1、按照数据类型：基本数据类型 vs 引用数据类型</p>
<p>2、按照在类中声明的位置：</p>
<p>2.1、成员变量 ：在使用前，都经历了默认初始化值</p>
<p>2.1.1、类变量（使用static修饰，又称静态变量）：linking的prepare阶段，默认赋值；initial阶段，显式赋值（静态代码块赋值）</p>
<p>2.1.2、实例变量（归具体的对象所有）：随着对象的创建，会堆空间中分配实例变量空间，并进行默认赋值</p>
<p>2.2、局部变量：在使用前，必须要进行显式赋值的！！！否则i，编译不通过。</p>
</blockquote>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407205201467.png" alt="image-20210407205201467"> </p>
<p><strong>补充说明</strong>：</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407211619440.png" alt="image-20210407211619440"> </p>
<h1 id="4、操作数栈"><a href="#4、操作数栈" class="headerlink" title="4、操作数栈"></a>4、操作数栈</h1><p><img src="/2021/04/15/05_虚拟机栈/image-20210407212537026.png" alt="image-20210407212537026"> </p>
<p><strong>举例</strong>：</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407213321977.png" alt="image-20210407213321977"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407213452826.png" alt="image-20210407213452826"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407213139897.png" alt="image-20210407213139897"> </p>
<h1 id="5、代码追踪"><a href="#5、代码追踪" class="headerlink" title="5、代码追踪"></a>5、代码追踪</h1><p>举例：</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407214129017.png" alt="image-20210407214129017"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407214305761.png" alt="image-20210407214305761"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407214341986.png" alt="image-20210407214341986"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407214619450.png" alt="image-20210407214619450"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407214712042.png" alt="image-20210407214712042"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407214747769.png" alt="image-20210407214747769"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407214824194.png" alt="image-20210407214824194"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407214946378.png" alt="image-20210407214946378"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210407215010138.png" alt="image-20210407215010138"> </p>
<p><strong>程序员面试过程中，常见的i++和++i的区别，放在字节码篇章时介绍</strong>。</p>
<h1 id="6、栈顶缓存技术"><a href="#6、栈顶缓存技术" class="headerlink" title="6、栈顶缓存技术"></a>6、栈顶缓存技术</h1><p><img src="/2021/04/15/05_虚拟机栈/image-20210407220839882.png" alt="image-20210407220839882"> </p>
<h1 id="7、动态链接（或指向运行时常量池的方法引用）"><a href="#7、动态链接（或指向运行时常量池的方法引用）" class="headerlink" title="7、动态链接（或指向运行时常量池的方法引用）"></a>7、动态链接（或指向运行时常量池的方法引用）</h1><p>写在前边：有些书上会把<strong>方法返回地址、动态链接和附加信息</strong>这三项称为<strong>帧数据区</strong>。</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408154730217.png" alt="image-20210408154730217"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/%E7%AC%AC09%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%8E%E6%A0%88%E7%9A%84%E5%85%B3%E8%81%94%E7%BB%93%E6%9E%84.jpg" alt="第09章_方法区与栈的关联结构"> </p>
<p><strong>思考</strong>：为什么需要常量池？常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</p>
<h1 id="8、方法的调用：解析与分派"><a href="#8、方法的调用：解析与分派" class="headerlink" title="8、方法的调用：解析与分派"></a>8、方法的调用：解析与分派</h1><h2 id="8-1、相关概念"><a href="#8-1、相关概念" class="headerlink" title="8.1、相关概念"></a>8.1、相关概念</h2><p>在JVM中，将<strong>符号引用</strong>转换为<strong>调用方法的直接引用</strong>与方法的<strong>绑定机制</strong>相关。</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408161813630.png" alt="image-20210408161813630"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408162128009.png" alt="image-20210408162128009"> </p>
<p>注：静态链接与早期绑定相对应，动态链接与晚期绑定向对应。</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408163442735.png" alt="image-20210408163442735"> </p>
<p>注：虚函数的特征，其实就是体现为直到在运行时才能被确定下来。C++的虚函数就像时Java的多态性，父类类型的引用指向子类的对象实例，实际调用的时候，是调用的子类重写的方法。如果不想这样，就不让方法被重写，加上final来标记此方法。</p>
<h2 id="8-2、虚方法和非虚方法"><a href="#8-2、虚方法和非虚方法" class="headerlink" title="8.2、虚方法和非虚方法"></a>8.2、虚方法和非虚方法</h2><p><strong>非虚方法</strong>：</p>
<blockquote>
<p>1、如果方法在编译期就确定了具体的调用版本，这个版本在运行期间是不可变的。这样的方法被称为<strong>非虚方法</strong>。</p>
<p>2、静态方法、私有方法、final方法、实例构造器方法、父类方法都是非虚方法。</p>
<p>3、其他方法被称为虚方法。</p>
</blockquote>
<p>注：子类对象的多态性的使用前提 —— 1、类的继承关系；2、方法的重写</p>
<p>虚方法与多态性是有对应关系的。</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408191909125.png" alt="image-20210408191909125"> </p>
<p>以下是一些实例：</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408201655438.png" alt="image-20210408201655438"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408201531062.png" alt="image-20210408201531062"> </p>
<p><strong>关于invokedynamic指令</strong>：</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408201934348.png" alt="image-20210408201934348"> </p>
<p><strong>动态类型语言和静态类型语言</strong>：</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408202212399.png" alt="image-20210408202212399"> </p>
<h2 id="8-3、方法重写的本质"><a href="#8-3、方法重写的本质" class="headerlink" title="8.3、方法重写的本质"></a>8.3、方法重写的本质</h2><p><img src="/2021/04/15/05_虚拟机栈/image-20210408203253143.png" alt="image-20210408203253143"> </p>
<h2 id="8-4、虚方法表"><a href="#8-4、虚方法表" class="headerlink" title="8.4、虚方法表"></a>8.4、虚方法表</h2><p><img src="/2021/04/15/05_虚拟机栈/image-20210408210447660.png" alt="image-20210408210447660"> </p>
<p><strong>举例1</strong>：</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408211714868.png" alt="image-20210408211714868"> </p>
<h1 id="9、方法的返回地址"><a href="#9、方法的返回地址" class="headerlink" title="9、方法的返回地址"></a>9、方法的返回地址</h1><p><img src="/2021/04/15/05_虚拟机栈/image-20210408213150002.png" alt="image-20210408213150002"> </p>
<p>注：<strong>PC寄存器中的值是该方法要执行的下一条指令的值</strong>。</p>
<p> <img src="/2021/04/15/05_虚拟机栈/image-20210408214319985.png" alt="image-20210408214319985"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408214658321.png" alt="image-20210408214658321"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408213845738.png" alt="image-20210408213845738"> </p>
<h1 id="10、一些附加信息"><a href="#10、一些附加信息" class="headerlink" title="10、一些附加信息"></a>10、一些附加信息</h1><p>了解一下就行了</p>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>
<h1 id="11、栈的相关面试题"><a href="#11、栈的相关面试题" class="headerlink" title="11、栈的相关面试题"></a>11、栈的相关面试题</h1><p><strong>1、举例栈溢出的情况</strong>：</p>
<p>StackOverflowError，可以通过 <code>-Xss</code>来设置栈的大小；栈的大小由固定的，还有动态变化的；还有一种OOM（OutOfMemoryError）；还有内存溢出和内存泄漏，这个在后边讲。</p>
<p><strong>2、调整栈的大小，可以保证不出现溢出吗</strong>？</p>
<p>有可能不出现溢出，但是不能保证不出现溢出</p>
<p><strong>3、分配的栈内存是越大越好吗</strong>？</p>
<p>不是。</p>
<p><strong>4、垃圾回收是否涉及到虚拟机栈</strong>？</p>
<p>不会的。</p>
<p>程序计数器：没有GC，没有溢出</p>
<p>虚拟机栈：没有GC，存在溢出</p>
<p>本地方法栈：没有GC，存在溢出</p>
<p>方法区：存在GC，存在溢出</p>
<p>堆：存在GC，存在溢出</p>
<p><strong>5、方法中定义的局部变量是否线程安全</strong>？</p>
<p>具体问题据分析</p>
<p>何为线程安全？</p>
<p>1、如果只有一个线程才可以操作此数据，则必是线程安全的</p>
<p>2、如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制，会存在线程安全问题。</p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408222202255.png" alt="image-20210408222202255"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408222242425.png" alt="image-20210408222242425"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408222333217.png" alt="image-20210408222333217"> </p>
<p><img src="/2021/04/15/05_虚拟机栈/image-20210408222507833.png" alt="image-20210408222507833"> </p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>06_本地方法接口</title>
    <url>/2021/04/15/06_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p><strong>概念</strong>：</p>
<span id="more"></span>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/06_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/%E7%AC%AC02%E7%AB%A0_JVM%E6%9E%B6%E6%9E%84-%E4%B8%AD.jpg" alt="第02章_JVM架构-中"></p>
<p><strong>什么是本地方法</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/06_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/image-20210409092111986.png" alt="image-20210409092111986"> </p>
<p><strong>举例</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/06_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/image-20210409092337236.png" alt="image-20210409092337236"> </p>
<p><strong>为什么要使用Native Method</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/06_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/image-20210409092544660.png" alt="image-20210409092544660"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/06_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/image-20210409092631545.png" alt="image-20210409092631545"> </p>
<p><strong>现状</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/06_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/image-20210409093356186.png" alt="image-20210409093356186"> </p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>08_堆</title>
    <url>/2021/04/15/08_%E5%A0%86/</url>
    <content><![CDATA[<h1 id="1、堆的核心概念"><a href="#1、堆的核心概念" class="headerlink" title="1、堆的核心概念"></a>1、堆的核心概念</h1><span id="more"></span>
<h2 id="1-1、基本概念"><a href="#1-1、基本概念" class="headerlink" title="1.1、基本概念"></a>1.1、基本概念</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411091825935.png" alt="image-20210411091825935"> </p>
<p><strong>一个java程序对应一个进程，一个进程就对应着一个JVM的实例，一个JVM实例中只有一个运行时数据区，里面只有一个方法区和一个堆，有多个线程共享同一个堆和方法区，每个线程都各自拥有一份程序计数器、本地方法栈和虚拟机栈</strong>。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411093005467.png" alt="image-20210411093005467"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411092900764.png" alt="image-20210411092900764"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411094154410.png" alt="image-20210411094154410"> </p>
<h2 id="1-2、内存细分"><a href="#1-2、内存细分" class="headerlink" title="1.2、内存细分"></a>1.2、内存细分</h2><p><strong>现代垃圾回收器大部分都基于分代收集理论的设计，堆空间细分为</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411095630434.png" alt="image-20210411095630434"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411191433730.png" alt="image-20210411191433730"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411191455563.png" alt="image-20210411191455563"> </p>
<p>注：逻辑上是存在三部分，实际上在设置堆空间大小时，是不包括元空间或永久区的</p>
<p>JDK8中内存结构有哪些变化，其中之一就是永久代变成了元空间</p>
<h1 id="2、设置堆内存大小与OOM"><a href="#2、设置堆内存大小与OOM" class="headerlink" title="2、设置堆内存大小与OOM"></a>2、设置堆内存大小与OOM</h1><h2 id="2-1、设置堆空间大小"><a href="#2-1、设置堆空间大小" class="headerlink" title="2.1、设置堆空间大小"></a>2.1、设置堆空间大小</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411100825064.png" alt="image-20210411100825064"> </p>
<p>注：<code>-Xms</code>：用来设置堆空间（年轻代 + 老年代）的初始内存大小。其中<code>-X</code>是<code>JVM</code>的运行参数；<code>ms</code>是memory start。</p>
<p><code>-Xms</code>：用来设置堆空间（年轻代 + 老年代）的最大内存大小。</p>
<p>如何查看设置的参数：方式一： <code>jps / jstat -gc 进程id</code>；**方式二：<code>-XX:PrintGCDetails</code>**。</p>
<h2 id="2-2、OOM（OutOfMemoryError）举例"><a href="#2-2、OOM（OutOfMemoryError）举例" class="headerlink" title="2.2、OOM（OutOfMemoryError）举例"></a>2.2、OOM（OutOfMemoryError）举例</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411183913199.png" alt="image-20210411183913199"> </p>
<p>注：Class Throwable有两个子类Error和Exception，这是狭义上的异常，广义上的异常，指的开发中遇到的凡是程序不正常的情况</p>
<h1 id="3、年轻代和老年代"><a href="#3、年轻代和老年代" class="headerlink" title="3、年轻代和老年代"></a>3、年轻代和老年代</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411184739512.png" alt="image-20210411184739512"> </p>
<p>注：堆中存储的东西现在Eden中，过了一段时间没有消亡，就转到survivor中，再过一会还是没有消亡，就会进入老年代。</p>
<p>图示：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411190410591.png" alt="image-20210411190410591"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411185410113.png" alt="image-20210411185410113"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411185827832.png" alt="image-20210411185827832"> </p>
<p>注：<code>-XX:UseAdaptiveSizePolicy</code>是用来关闭自适应的内存分配策略</p>
<p>如果<code>-Xmn</code>和<code>NewRatio</code>冲突的话，以<code>-Xmn</code>为准。（一般会不设置）</p>
<h1 id="4、图解对象分配过程"><a href="#4、图解对象分配过程" class="headerlink" title="4、图解对象分配过程"></a>4、图解对象分配过程</h1><h2 id="4-1、一般过程"><a href="#4-1、一般过程" class="headerlink" title="4.1、一般过程"></a>4.1、一般过程</h2><p><strong>概述</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411191547334.png" alt="image-20210411191547334"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411191702038.png" alt="image-20210411191702038"> </p>
<p>注：Eden区满的时候会触发YGC/Minor GC，但是survivor区满的时候不会触发；当Eden区满的时候，会将Eden区和Survivor区一起回收。有的对象刚创建就在老年区了，还有的age没有达到15，也进入了老年代。</p>
<p><strong>图解</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/%E7%AC%AC08%E7%AB%A0_%E6%96%B0%E7%94%9F%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.jpg" alt="第08章_新生代对象分配与回收过程"> </p>
<p><strong>总结</strong>：</p>
<blockquote>
<p>1、针对幸存者s0，s1的总结：复制之后有交换，谁空谁是to</p>
<p>2、关于垃圾回收：频繁在新生代收集，很少在老年代收集，几乎不再永久代/元空间收集。</p>
</blockquote>
<h2 id="4-2、特殊情况"><a href="#4-2、特殊情况" class="headerlink" title="4.2、特殊情况"></a>4.2、特殊情况</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411200223566.png" alt="image-20210411200223566"> </p>
<p>注：YGC之后，Eden区一定是空的。</p>
<h2 id="4-3、代码示例"><a href="#4-3、代码示例" class="headerlink" title="4.3、代码示例"></a>4.3、代码示例</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411201134973.png" alt="image-20210411201134973"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411201415645.png" alt="image-20210411201415645"> </p>
<h2 id="4-4、常用的调优工具"><a href="#4-4、常用的调优工具" class="headerlink" title="4.4、常用的调优工具"></a>4.4、常用的调优工具</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411202512138.png" alt="image-20210411202512138"> </p>
<h1 id="5、Minor-GC、Major-GC、Full-GC"><a href="#5、Minor-GC、Major-GC、Full-GC" class="headerlink" title="5、Minor GC、Major GC、Full GC"></a>5、Minor GC、Major GC、Full GC</h1><h2 id="5-1、三类GC的区别"><a href="#5-1、三类GC的区别" class="headerlink" title="5.1、三类GC的区别"></a>5.1、三类GC的区别</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411203112140.png" alt="image-20210411203112140"> </p>
<p>注：所谓调优，就是希望垃圾回收的次数少一些。Major GC和Full GC的时间比Minor GC长很多，主要是让他们回收的次数少一些。而且Major GC和Full GC的区分很重要。</p>
<h2 id="5-2、最简单的分代式GC策略的触发条件"><a href="#5-2、最简单的分代式GC策略的触发条件" class="headerlink" title="5.2、最简单的分代式GC策略的触发条件"></a>5.2、最简单的分代式GC策略的触发条件</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411204902770.png" alt="image-20210411204902770"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411205142708.png" alt="image-20210411205142708"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411205241652.png" alt="image-20210411205241652"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411205439930.png" alt="image-20210411205439930"> </p>
<h1 id="6、堆空间的分代思想"><a href="#6、堆空间的分代思想" class="headerlink" title="6、堆空间的分代思想"></a>6、堆空间的分代思想</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411211524073.png" alt="image-20210411211524073"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411211618889.png" alt="image-20210411211618889"> </p>
<h1 id="7、内存分配策略（或对象提升（Promotion）规则）"><a href="#7、内存分配策略（或对象提升（Promotion）规则）" class="headerlink" title="7、内存分配策略（或对象提升（Promotion）规则）"></a>7、内存分配策略（或对象提升（Promotion）规则）</h1><p><strong>一般原则</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411212133633.png" alt="image-20210411212133633"> </p>
<p><strong>特殊情况</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411212218809.png" alt="image-20210411212218809"> </p>
<h1 id="8、为对象分配内存：TLAB"><a href="#8、为对象分配内存：TLAB" class="headerlink" title="8、为对象分配内存：TLAB"></a>8、为对象分配内存：TLAB</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411213253889.png" alt="image-20210411213253889"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411213415969.png" alt="image-20210411213415969"> </p>
<p><strong>图示</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411213533152.png" alt="image-20210411213533152"> </p>
<p><strong>TLAB再说明</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411213715897.png" alt="image-20210411213715897"> </p>
<p>注：TLAB默认是开启状态。</p>
<p><strong>对象分配过程：TLAB</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411214200826.png" alt="image-20210411214200826"> </p>
<h1 id="9、小结：堆的参数设置"><a href="#9、小结：堆的参数设置" class="headerlink" title="9、小结：堆的参数设置"></a>9、小结：堆的参数设置</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411214723927.png" alt="image-20210411214723927"> </p>
<p>注：具体查看某个参数的指令：1、jps：用来查看当前运行的进程号；2、jinfo -flag 某参数名 进程id</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411215043630.png" alt="image-20210411215043630"> </p>
<p><strong>空间分配担保</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411220702977.png" alt="image-20210411220702977"> </p>
<h1 id="X、堆是分配对象的唯一选择吗？不是"><a href="#X、堆是分配对象的唯一选择吗？不是" class="headerlink" title="X、堆是分配对象的唯一选择吗？不是"></a>X、堆是分配对象的唯一选择吗？不是</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411221533744.png" alt="image-20210411221533744"> </p>
<h2 id="X-1、逃逸分析"><a href="#X-1、逃逸分析" class="headerlink" title="X.1、逃逸分析"></a>X.1、逃逸分析</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411223743896.png" alt="image-20210411223743896"> </p>
<p><strong>举例1</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411224036862.png" alt="image-20210411224036862"> </p>
<p><strong>举例2</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411224109462.png" alt="image-20210411224109462"> </p>
<p><strong>举例3</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411224232302.png" alt="image-20210411224232302"> </p>
<p><strong>如何快速判断是否发生了逃逸分析</strong>？大家就看new的<strong>对象实体</strong>是否在方法外被调用。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411224531709.png" alt="image-20210411224531709"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411224630021.png" alt="image-20210411224630021"> </p>
<p>上图最后一项，对象实体不是方法中的，是在方法外。</p>
<p><strong>只要没有发生逃逸，就可以考虑栈上分配</strong>。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210411225024309.png" alt="image-20210411225024309"> </p>
<p><strong>结论：开发中能够使用局部变量的，就不要使用方法外定义</strong>。</p>
<h2 id="X-2、逃逸分析：代码优化"><a href="#X-2、逃逸分析：代码优化" class="headerlink" title="X.2、逃逸分析：代码优化"></a>X.2、逃逸分析：代码优化</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210412090818021.png" alt="image-20210412090818021"> </p>
<p><strong>栈上分配</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210412091130630.png" alt="image-20210412091130630"> </p>
<p>注：没有发生逃逸的就可以进行栈上分配。</p>
<p><strong>同步省略</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210412092025429.png" alt="image-20210412092025429"> </p>
<p>注：如果锁对象没有逃逸，就可以进行锁消除。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210412092216518.png" alt="image-20210412092216518"> </p>
<p><strong>标量替换或分离对象</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210412093620746.png" alt="image-20210412093620746"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210412093930576.png" alt="image-20210412093930576"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210412094208888.png" alt="image-20210412094208888"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210412094852000.png" alt="image-20210412094852000"> </p>
<h2 id="X-3、逃逸分析小结：逃逸分析还不是很成熟"><a href="#X-3、逃逸分析小结：逃逸分析还不是很成熟" class="headerlink" title="X.3、逃逸分析小结：逃逸分析还不是很成熟"></a>X.3、逃逸分析小结：逃逸分析还不是很成熟</h2><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210412095059089.png" alt="image-20210412095059089"> </p>
<p><strong>注</strong>：Oracle Hotspot VM中并未应用栈上分配，是用的标量替换而产生的同样的效果。所以栈上没有存对象，对象还是存在堆里。栈上是存的标量，并不是对象。</p>
<p><strong>以上是目前的理解，之后看书啥的可能还会变</strong>。</p>
<h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/08_%E5%A0%86/image-20210412095521608.png" alt="image-20210412095521608"> </p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>09_方法区</title>
    <url>/2021/04/15/09_%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="1、栈、堆、方法区的交互关系"><a href="#1、栈、堆、方法区的交互关系" class="headerlink" title="1、栈、堆、方法区的交互关系"></a>1、栈、堆、方法区的交互关系</h1><span id="more"></span>
<p><strong>运行时数据区结构图</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412155210227.png" alt="image-20210412155210227"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412155332427.png" alt="image-20210412155332427"> </p>
<p><strong>举例</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412155534899.png" alt="image-20210412155534899"> </p>
<p><img src="/2021/04/15/09_方法区/%E7%AC%AC10%E7%AB%A0_%E6%96%B9%E5%BC%8F2%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.jpg" alt="第10章_方式2：使用直接指针访问"> </p>
<h1 id="2、方法区的理解"><a href="#2、方法区的理解" class="headerlink" title="2、方法区的理解"></a>2、方法区的理解</h1><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html</a></p>
<p><strong>方法区在哪里</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412160941312.png" alt="image-20210412160941312"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412161847960.png" alt="image-20210412161847960"> </p>
<p><strong>HotSpot中方法区的演进</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412162020664.png" alt="image-20210412162020664"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412162639263.png" alt="image-20210412162639263"> </p>
<p>注：可以将方法区比作接口，将永久代和元空间当成是接口的实现类。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412162516833.png" alt="image-20210412162516833"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412162536972.png" alt="image-20210412162536972"> </p>
<h1 id="3、设置方法区大小与OOM"><a href="#3、设置方法区大小与OOM" class="headerlink" title="3、设置方法区大小与OOM"></a>3、设置方法区大小与OOM</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412163135607.png" alt="image-20210412163135607"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412163223870.png" alt="image-20210412163223870"> </p>
<p><strong>代码举例</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412164148990.png" alt="image-20210412164148990"> </p>
<p>注：元空间设置的空间大小不足的时候，会报OOM。</p>
<p><strong>如何解决这些OOM</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412164513654.png" alt="image-20210412164513654"> </p>
<p>注：之后在调优中会有详细的讲解。</p>
<h1 id="4、方法区的内部结构"><a href="#4、方法区的内部结构" class="headerlink" title="4、方法区的内部结构"></a>4、方法区的内部结构</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412193741280.png" alt="image-20210412193741280"> </p>
<p>方法区主要存储以及能够被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译后的代码缓存等</strong>。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/%E7%AC%AC09%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%98%E5%82%A8%E4%BF%A1%E6%81%AF.jpg" alt="第09章_方法区存储信息"> </p>
<p>注：可以将<strong>域信息和方法信息</strong>涵盖在类型信息中的。这些方法区的内部结构可以看成是经典的结构，新的可能会有些许变动。</p>
<p><strong>类型信息</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412194553138.png" alt="image-20210412194553138"> </p>
<p><strong>域（Field）信息（成员变量）</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412194812879.png" alt="image-20210412194812879"> </p>
<p><strong>方法（Method）信息</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412194912498.png" alt="image-20210412194912498"> </p>
<p>注：反编译字节码文件：<code>javap -v -p 文件名.class &gt; 文件名.txt</code></p>
<p><strong>non-final的类变量</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412200253297.png" alt="image-20210412200253297"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412200420327.png" alt="image-20210412200420327"> 注：不管new不new对象，第二行都是可以直接访问的</p>
<p><strong>全局常量（static final修饰）：被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会分配了</strong>。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412201800517.png" alt="image-20210412201800517"> </p>
<p>注：带final的类变量number编译成字节码的时候就赋值了。不带final的类变量，在类加载子系统的链接的准备阶段默认初始化为0，在初始化阶段才赋值1。</p>
<p><strong>运行时常量池vs常量池</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412202700581.png" alt="image-20210412202700581"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412202816172.png" alt="image-20210412202816172"> </p>
<p><strong>常量池</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412203409516.png" alt="image-20210412203409516"> </p>
<p>注：<em>字面量</em>（literal）是用于表达源代码中一个固定值的表示法。</p>
<p><strong>为什么需要常量池</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412203759166.png" alt="image-20210412203759166"> </p>
<p>注：常量池中是一些符号引用，真正要用到的时候，符号引用变成了直接引用。字节码文件里的<code>#5</code>等符号就是符号引用，代码执行的细节都是从常量池中调的，用到啥调啥。就像炒菜一样，缺啥调料，就去调料区调，常量池里就是放的各种各样的调料，而每一道菜就是一段代码。</p>
<p><strong>常量池中有什么</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412210727305.png" alt="image-20210412210727305"> </p>
<p><strong>小结：常量池，可以看成是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</strong>。</p>
<p><strong>运行时常量池</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412212247552.png" alt="image-20210412212247552"> </p>
<h1 id="5、方法区的使用举例"><a href="#5、方法区的使用举例" class="headerlink" title="5、方法区的使用举例"></a>5、方法区的使用举例</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412212634432.png" alt="image-20210412212634432"> </p>
<p><strong>执行过程</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412212958760.png" alt="image-20210412212958760"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412213229992.png" alt="image-20210412213229992"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412213324969.png" alt="image-20210412213324969"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412213526864.png" alt="image-20210412213526864"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412213622631.png" alt="image-20210412213622631"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412213745022.png" alt="image-20210412213745022"> </p>
<p> <img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412213837022.png" alt="image-20210412213837022"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412214014239.png" alt="image-20210412214014239"> </p>
<p><strong>10：istore_3</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412214159758.png" alt="image-20210412214159758"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412214227551.png" alt="image-20210412214227551"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412214306385.png" alt="image-20210412214306385"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412214500251.png" alt="image-20210412214500251"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412214540814.png" alt="image-20210412214540814"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412214608567.png" alt="image-20210412214608567"> </p>
<p> <img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412214628413.png" alt="image-20210412214628413"> </p>
<p><strong>关于程序计数器（个人理解）：首先按程序计数器（PC）所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，与此同时将PC的值加1指向下一条要执行的指令。程序计数器是用于存放下一条指令所在单元的地址的地方</strong>。</p>
<h1 id="6、方法区的演进细节"><a href="#6、方法区的演进细节" class="headerlink" title="6、方法区的演进细节"></a>6、方法区的演进细节</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412220507968.png" alt="image-20210412220507968"> </p>
<p><strong>各个版本图例</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412221004060.png" alt="image-20210412221004060"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412221055594.png" alt="image-20210412221055594"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412221124250.png" alt="image-20210412221124250"> </p>
<p><strong>永久代为什么被元空间替换</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210412221807619.png" alt="image-20210412221807619">  </p>
<p><strong>StringTable为什么要调整</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210413200359603.png" alt="image-20210413200359603"> </p>
<p>注：后面有专门的章节将这个StringTable。</p>
<p><strong>静态变量放在哪里</strong>？</p>
<p>示例1：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210413200717689.png" alt="image-20210413200717689"> </p>
<p>示例2：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210413200758960.png" alt="image-20210413200758960"> </p>
<p><strong>结论</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210413201408096.png" alt="image-20210413201408096"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210413201634553.png" alt="image-20210413201634553"> </p>
<p>这个实例来自《深入理解JVM》。</p>
<h1 id="7、方法区的垃圾回收"><a href="#7、方法区的垃圾回收" class="headerlink" title="7、方法区的垃圾回收"></a>7、方法区的垃圾回收</h1><p><strong>方法区的垃圾收集</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210413204000986.png" alt="image-20210413204000986"> </p>
<p><strong>常量池</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210413204348817.png" alt="image-20210413204348817"> </p>
<p><strong>不再使用的类</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210413204518753.png" alt="image-20210413204518753"> </p>
<h1 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/%E7%AC%AC09%E7%AB%A0_%E5%B0%8F%E7%BB%93.jpg" alt="第09章_小结"> </p>
<p><strong>常见面试题</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210413205523930.png" alt="image-20210413205523930"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/09_%E6%96%B9%E6%B3%95%E5%8C%BA/image-20210413205627549.png" alt="image-20210413205627549"> </p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>07_本地方法栈</title>
    <url>/2021/04/15/07_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</url>
    <content><![CDATA[<p><strong>相关概念</strong>： </p>
<span id="more"></span>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/07_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/image-20210409094130147.png" alt="image-20210409094130147"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/07_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/image-20210409095052762.png" alt="image-20210409095052762"> </p>
<p><strong>举例</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/07_%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/image-20210409094940990.png" alt="image-20210409094940990"> </p>
<p>本章之前的内容回顾请看视频<a href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=65">P65_JVM学习路线与内容回顾</a></p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>10_对象的实例化、内存布局与访问定位</title>
    <url>/2021/04/15/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="1、对象的实例化"><a href="#1、对象的实例化" class="headerlink" title="1、对象的实例化"></a>1、对象的实例化</h1><span id="more"></span>
<p><strong>大厂面试题</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210413212638125.png" alt="image-20210413212638125"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96.jpg" alt="第10章_对象的实例化"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210413215220856.png" alt="image-20210413215220856"> </p>
<p><strong>创建对象的步骤</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210413213949625.png" alt="image-20210413213949625"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210413214010537.png" alt="image-20210413214010537"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210413214030953.png" alt="image-20210413214030953"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210413214046736.png" alt="image-20210413214046736"> </p>
<h1 id="2、对象的内存布局"><a href="#2、对象的内存布局" class="headerlink" title="2、对象的内存布局"></a>2、对象的内存布局</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/%E7%AC%AC10%E7%AB%A0_%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="第10章_内存布局"> </p>
<p><strong>示例程序</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210413220434208.png" alt="image-20210413220434208"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210413220441975.png" alt="image-20210413220441975"> </p>
<p><strong>内存布局的图示</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/%E7%AC%AC10%E7%AB%A0_%E5%9B%BE%E7%A4%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="第10章_图示对象的内存布局"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="第10章_对象的内存布局"> </p>
<h1 id="3、对象的访问定位"><a href="#3、对象的访问定位" class="headerlink" title="3、对象的访问定位"></a>3、对象的访问定位</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/%E7%AC%AC10%E7%AB%A0_%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.jpg" alt="第10章_对象访问定位"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210413220742842.png" alt="image-20210413220742842"> </p>
<p><strong>句柄访问</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/%E7%AC%AC10%E7%AB%A0_%E6%96%B9%E5%BC%8F1%EF%BC%9A%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.jpg" alt="第10章_方式1：句柄访问"> </p>
<p><strong>直接指针</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/10_%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/%E7%AC%AC10%E7%AB%A0_%E6%96%B9%E5%BC%8F2%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.jpg" alt="第10章_方式2：使用直接指针访问"> </p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>11_直接内存</title>
    <url>/2021/04/15/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p><strong>概述</strong>：</p>
<span id="more"></span>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/image-20210414092706540.png" alt="image-20210414092706540"> </p>
<p><strong>访问直接内存速度比Java堆快</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/image-20210414093343472.png" alt="image-20210414093343472"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/image-20210414093534681.png" alt="image-20210414093534681"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/image-20210414093937848.png" alt="image-20210414093937848"> </p>
<p>注：Direct buffer memory </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/11_%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/image-20210414100309126.png" alt="image-20210414100309126"> </p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>12_执行引擎</title>
    <url>/2021/04/15/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="1、执行引擎概述"><a href="#1、执行引擎概述" class="headerlink" title="1、执行引擎概述"></a>1、执行引擎概述</h1><span id="more"></span>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414102042869.png" alt="image-20210414102042869"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414101959189.png" alt="image-20210414101959189"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414150714268.png" alt="image-20210414150714268"> </p>
<p>举例：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414151505428.png" alt="image-20210414151505428"> 注：这个翻译官就是执行引擎的角色。</p>
<p><strong>执行引擎的工作过程</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414152454707.png" alt="image-20210414152454707"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414153146529.png" alt="image-20210414153146529"> </p>
<h1 id="2、Java代码编译和执行过程"><a href="#2、Java代码编译和执行过程" class="headerlink" title="2、Java代码编译和执行过程"></a>2、Java代码编译和执行过程</h1><p><strong>整体流程</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/%E7%AC%AC12%E7%AB%A0_%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="第12章_程序执行过程"> </p>
<p>注：大部分的程序代码转换成物理机的目标代码或者虚拟机能执行的指令集之前，都需要经过上图的各个步骤。</p>
<p>橙色部分：由javac编译器完成的，或者称为前端编译器。Java是半解释型半编译型，绿色部分是解释，蓝色部分是编译。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414154216864.png" alt="image-20210414154216864"> </p>
<p>注：对应橙色的部分</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414154302407.png" alt="image-20210414154302407"> </p>
<p>注：上边对应的是蓝色部分，下边对应的是绿色部分。</p>
<p><strong>问题：什么是解释器（Interpreter）？什么是<code>JIT</code>编译器</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414155123120.png" alt="image-20210414155123120"> </p>
<p><strong>问题：为什么说Java是半编译半解释型语言</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414155705712.png" alt="image-20210414155705712"> </p>
<p><strong>注：解释器是指的送过来一条指令，就给翻译成本地机器指令，然后扔去执行，执行完就再接一条指令，翻译一下去执行，并没有将其保存下来；JIT编译器是指的一大段指令经常执行，然后将这一大段指令一块儿都翻译成本地机器指令，缓存起来，等啥时候用到了，直接拿过来用就行，这样就避免了重复翻译指令，节省了时间。</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/%E7%AC%AC12%E7%AB%A0_%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.jpg" alt="第12章_理解执行引擎"> </p>
<h1 id="3、机器码、指令、汇编语言"><a href="#3、机器码、指令、汇编语言" class="headerlink" title="3、机器码、指令、汇编语言"></a>3、机器码、指令、汇编语言</h1><p><strong>机器码</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414161112061.png" alt="image-20210414161112061"> </p>
<p><strong>指令</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414162902113.png" alt="image-20210414162902113"> </p>
<p><strong>指令集</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414162928067.png" alt="image-20210414162928067"> </p>
<p><strong>汇编语言</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414163248994.png" alt="image-20210414163248994"> </p>
<p><strong>高级语言</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414163446661.png" alt="image-20210414163446661"> </p>
<p><img src="/2021/04/15/12_执行引擎/%E7%AC%AC12%E7%AB%A0_%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80.jpg" alt="第12章_机器语言、汇编、高级语言"> </p>
<p><strong>字节码</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414164350259.png" alt="image-20210414164350259"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414164138826.png" alt="image-20210414164138826"> </p>
<h1 id="4、解释器"><a href="#4、解释器" class="headerlink" title="4、解释器"></a>4、解释器</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414164848506.png" alt="image-20210414164848506"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/%E7%AC%AC12%E7%AB%A0_%E7%90%86%E8%A7%A3%E4%B8%AD%E9%97%B4%E8%BF%87%E7%A8%8B.jpg" alt="第12章_理解中间过程"> </p>
<p><strong>工作机制（或工作任务）</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414190839665.png" alt="image-20210414190839665"> </p>
<p><strong>解释器分类（了解）</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414191027454.png" alt="image-20210414191027454"> </p>
<p><strong>现状</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414191312410.png" alt="image-20210414191312410"> </p>
<h1 id="5、JIT编译器"><a href="#5、JIT编译器" class="headerlink" title="5、JIT编译器"></a>5、JIT编译器</h1><p><strong>Java代码的执行分类</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414191650161.png" alt="image-20210414191650161"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414191731744.png" alt="image-20210414191731744"> </p>
<p><strong>问题来了</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414192153232.png" alt="image-20210414192153232"> </p>
<p><strong>HotSpot JVM的执行方式</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414192338761.png" alt="image-20210414192338761"> </p>
<p><strong>案例来了</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414192614874.png" alt="image-20210414192614874"> </p>
<p><strong>概念解释</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414193036922.png" alt="image-20210414193036922"> </p>
<p><strong>热点代码及探测方式</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414193440073.png" alt="image-20210414193440073"> </p>
<p><strong>多少次算是多（可以看成是热点代码）呢</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414193541680.png" alt="image-20210414193541680"> </p>
<p><strong>方法调用计数器</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414193808263.png" alt="image-20210414193808263"> </p>
<p><strong>看图说话</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414194602325.png" alt="image-20210414194602325"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/%E7%AC%AC12%E7%AB%A0_%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8.jpg" alt="第12章_方法调用计数器"> </p>
<p><strong>热度衰减</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414194909293.png" alt="image-20210414194909293"> </p>
<p><strong>回边计数器</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414195146541.png" alt="image-20210414195146541"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/%E7%AC%AC12%E7%AB%A0_%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8.jpg" alt="第12章_回边计数器"> </p>
<p><strong>HotSpot VM可以设置程序执行方式</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414195715788.png" alt="image-20210414195715788"> </p>
<p>注：<code>java -Xint -version</code>；<code>java -Xcomp -version</code></p>
<p><strong>HotSpot VM中的JIT分类</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414200853114.png" alt="image-20210414200853114"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414200950469.png" alt="image-20210414200950469"> </p>
<p>注：了解就行。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414201250122.png" alt="image-20210414201250122"> </p>
<p><strong>写在最后1：Graal编译器</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414201340483.png" alt="image-20210414201340483"> </p>
<p><strong>写在最后2：AOT编译器</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414201846643.png" alt="image-20210414201846643"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/12_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210414201927273.png" alt="image-20210414201927273"> </p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>13_StringTable</title>
    <url>/2021/04/15/13_StringTable/</url>
    <content><![CDATA[<h1 id="1、String的基本特性"><a href="#1、String的基本特性" class="headerlink" title="1、String的基本特性"></a>1、String的基本特性</h1><span id="more"></span>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414205555416.png" alt="image-20210414205555416"> </p>
<p><strong>String在jdk9中存储结构的变更</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414205128591.png" alt="image-20210414205128591"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414205508647.png" alt="image-20210414205508647"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414205625671.png" alt="image-20210414205625671"> </p>
<p><strong>不可变性的例子</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414210449413.png" alt="image-20210414210449413"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414210402094.png" alt="image-20210414210402094"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414210642147.png" alt="image-20210414210642147"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414210857653.png" alt="image-20210414210857653"> </p>
<p><strong>字符串常量池中是不会存储相同内容的字符串的</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414211528933.png" alt="image-20210414211528933"> </p>
<h1 id="2、String的内存分配"><a href="#2、String的内存分配" class="headerlink" title="2、String的内存分配"></a>2、String的内存分配</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414212021292.png" alt="image-20210414212021292"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414212151636.png" alt="image-20210414212151636"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414212847906.png" alt="image-20210414212847906"> </p>
<h1 id="3、String的基本操作"><a href="#3、String的基本操作" class="headerlink" title="3、String的基本操作"></a>3、String的基本操作</h1><p><a href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=121&spm_id_from=pageDriver">示例讲解视频</a>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414213253267.png" alt="image-20210414213253267"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210414213313474.png" alt="image-20210414213313474"> </p>
<h1 id="4、字符串拼接操作"><a href="#4、字符串拼接操作" class="headerlink" title="4、字符串拼接操作"></a>4、字符串拼接操作</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415145420503.png" alt="image-20210415145420503"> </p>
<p><strong>常量与常量，编译期优化</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415145919253.png" alt="image-20210415145919253"> </p>
<p><strong>比较练习</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415150227463.png" alt="image-20210415150227463"> </p>
<p><strong>带变量的拼接</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415151718885.png" alt="image-20210415151718885"> </p>
<p><strong>final的量</strong>：</p>
<p> <img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415152241067.png" alt="image-20210415152241067"> </p>
<p>反编译之后的</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415151841218.png" alt="image-20210415151841218"> </p>
<p><strong>练习</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415152727395.png" alt="image-20210415152727395"> </p>
<p><strong>总结</strong>：</p>
<blockquote>
<p>体会执行效率：通过StringBuilder的append()方法添加字符串的效率要远高于使用String的字符串拼接方式！！！</p>
<p>详情：一、StringBuilder的append方式：自始至终只创建一个StringBuilder的对象；使用String字符串拼接方式：创建了多个StringBuilder的对象</p>
<p>​    二：使用String的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用过大；如果进行GC，需要花费额外的时间。</p>
<p>改进空间：在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highlevel的情况下，建议使用构造器：</p>
<p><code>StringBuilder s = new StringBuilder(highlevel);//new char[highlevel]</code></p>
</blockquote>
<h1 id="5、intern-的使用"><a href="#5、intern-的使用" class="headerlink" title="5、intern()的使用"></a>5、intern()的使用</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415160955279.png" alt="image-20210415160955279"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415161020527.png" alt="image-20210415161020527"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415161521145.png" alt="image-20210415161521145"> </p>
<p><strong><a href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=126">面试题目：new String(“ab”)会创建几个对象？</a></strong>.</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415162851543.png" alt="image-20210415162851543"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415164100605.png" alt="image-20210415164100605"> </p>
<p><strong>注：new String(“ab”)会创建两个对象是因为使用字面量创建了对象”ab”，是使用字面量导致了常量池中有了这个对象；当使用数组构造String对象的时候，自然就没有加入常量池的操作了</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415163508262.png" alt="image-20210415163508262"> </p>
<p><strong>注：StringBuilder的toString方法，在返回的String对象中的值是直接将Stringbuider拼接完char型数组的value值付给他，并不是在常量池中的</strong>。</p>
<p><strong>面试难题：</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415165238887.png" alt="image-20210415165238887"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415164537919.png" alt="image-20210415164537919"> </p>
<p> <img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415164604309.png" alt="image-20210415164604309"> </p>
<p><strong>关于intern的总结</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415193942372.png" alt="image-20210415193942372"> </p>
<p><strong>练习1</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415194956161.png" alt="image-20210415194956161"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415194909778.png" alt="image-20210415194909778"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415195448033.png" alt="image-20210415195448033"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415195947989.png" alt="image-20210415195947989"> </p>
<p><strong>结论：对于程序中大量存在的字符串，尤其是存在很多重复的字符串时，使用intern()可以节省内存空间</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415201753917.png" alt="image-20210415201753917"> </p>
<h1 id="6、StringTable的垃圾回收"><a href="#6、StringTable的垃圾回收" class="headerlink" title="6、StringTable的垃圾回收"></a>6、StringTable的垃圾回收</h1><h1 id="7、G1中的String去重操作"><a href="#7、G1中的String去重操作" class="headerlink" title="7、G1中的String去重操作"></a>7、G1中的String去重操作</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415202152902.png" alt="image-20210415202152902"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415202400719.png" alt="image-20210415202400719"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415202650950.png" alt="image-20210415202650950"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/13_StringTable/image-20210415202747919.png" alt="image-20210415202747919"> </p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>14_垃圾回收概述.md</title>
    <url>/2021/04/16/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="1、什么是垃圾？"><a href="#1、什么是垃圾？" class="headerlink" title="1、什么是垃圾？"></a>1、什么是垃圾？</h1><span id="more"></span>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416090331691.png" alt="image-20210416090331691"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416090509979.png" alt="image-20210416090509979"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416090944477.png" alt="image-20210416090944477"> </p>
<p><strong>大厂面试题</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416090730731.png" alt="image-20210416090730731"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416090823651.png" alt="image-20210416090823651"> </p>
<h1 id="2、为什么需要GC？"><a href="#2、为什么需要GC？" class="headerlink" title="2、为什么需要GC？"></a>2、为什么需要GC？</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416091415130.png" alt="image-20210416091415130"> </p>
<h1 id="3、早期垃圾回收"><a href="#3、早期垃圾回收" class="headerlink" title="3、早期垃圾回收"></a>3、早期垃圾回收</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416092646732.png" alt="image-20210416092646732"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416092820741.png" alt="image-20210416092820741"> </p>
<h1 id="4、Java垃圾回收机制"><a href="#4、Java垃圾回收机制" class="headerlink" title="4、Java垃圾回收机制"></a>4、Java垃圾回收机制</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416092938988.png" alt="image-20210416092938988"> </p>
<p><strong>担忧</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416093113740.png" alt="image-20210416093113740"> </p>
<p><strong>应该关心哪些区域</strong>？</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416093428860.png" alt="image-20210416093428860"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/14_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/image-20210416093638343.png" alt="image-20210416093638343"> </p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>15_垃圾回收相关算法</title>
    <url>/2021/04/18/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>从面试角度，这一章还是比较重要的</strong>！！！</p>
<span id="more"></span>

<h1 id="1、标记阶段：引用计数算法"><a href="#1、标记阶段：引用计数算法" class="headerlink" title="1、标记阶段：引用计数算法"></a>1、标记阶段：引用计数算法</h1><p><strong>对象存活判断</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417201557710.png" alt="image-20210417201557710"> </p>
<p><strong>方式一：引用计数算法</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417202127743.png" alt="image-20210417202127743"> </p>
<p>注：<strong>无法循环引用，Java的GC没有采用这种算法</strong></p>
<p> <img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417202539296.png" alt="image-20210417202539296"> </p>
<p><strong>举例</strong>：</p>
<p> <img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417202843631.png" alt="image-20210417202843631"> </p>
<p><strong>小结</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417203112303.png" alt="image-20210417203112303"> </p>
<h1 id="2、标记阶段：可达性分析算法"><a href="#2、标记阶段：可达性分析算法" class="headerlink" title="2、标记阶段：可达性分析算法"></a>2、标记阶段：可达性分析算法</h1><p><strong>方式二：可达性分析（或根搜索算法、追踪性垃圾收集）</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417203829110.png" alt="image-20210417203829110"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417203904582.png" alt="image-20210417203904582"> 、</p>
<p><strong>举例</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417204229614.png" alt="image-20210417204229614"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417204100096.png" alt="image-20210417204100096"> </p>
<p>注：葡萄、人民的名义关系网</p>
<p><strong>GC Roots</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417204307991.png" alt="image-20210417204307991"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417204626638.png" alt="image-20210417204626638"> </p>
<p><strong>“临时性”</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417204708670.png" alt="image-20210417204708670"> </p>
<p><strong>注意</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417205024127.png" alt="image-20210417205024127"> </p>
<h1 id="3、对象的finalization机制"><a href="#3、对象的finalization机制" class="headerlink" title="3、对象的finalization机制"></a>3、对象的finalization机制</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417210556133.png" alt="image-20210417210556133"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417210840165.png" alt="image-20210417210840165"> </p>
<p><strong>生存还是死亡？</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417211211550.png" alt="image-20210417211211550"> </p>
<p><strong>具体过程</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417212121365.png" alt="image-20210417212121365"> </p>
<p>注：这个Finalize方法像是一块免死金牌。</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210417213026060.png" alt="image-20210417213026060"> </p>
<h1 id="4、MAT与JProfiler的GC-Roots溯源"><a href="#4、MAT与JProfiler的GC-Roots溯源" class="headerlink" title="4、MAT与JProfiler的GC Roots溯源"></a>4、MAT与JProfiler的GC Roots溯源</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418100130885.png" alt="image-20210418100130885"> </p>
<p><strong>获取dump文件</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418100521782.png" alt="image-20210418100521782"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418100703901.png" alt="image-20210418100703901"> </p>
<h1 id="5、清除阶段：标记-清除算法"><a href="#5、清除阶段：标记-清除算法" class="headerlink" title="5、清除阶段：标记-清除算法"></a>5、清除阶段：标记-清除算法</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418103623845.png" alt="image-20210418103623845"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418103740342.png" alt="image-20210418103740342"> </p>
<p>注：标记的不是垃圾。</p>
<p><strong>图示</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/%E7%AC%AC14%E7%AB%A0_%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg" alt="第14章_标记-清除算法"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418104440158.png" alt="image-20210418104440158"> </p>
<h1 id="6、清除阶段：复制算法"><a href="#6、清除阶段：复制算法" class="headerlink" title="6、清除阶段：复制算法"></a>6、清除阶段：复制算法</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418104825558.png" alt="image-20210418104825558"> </p>
<p><strong>图示</strong>：</p>
<p><img src="/2021/04/18/15_垃圾回收相关算法/%E7%AC%AC14%E7%AB%A0_%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt="第14章_复制算法"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418105204158.png" alt="image-20210418105204158"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418105650967.png" alt="image-20210418105650967"> </p>
<h1 id="7、清除阶段：标记-压缩算法"><a href="#7、清除阶段：标记-压缩算法" class="headerlink" title="7、清除阶段：标记-压缩算法"></a>7、清除阶段：标记-压缩算法</h1><p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418105739470.png" alt="image-20210418105739470"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418105917958.png" alt="image-20210418105917958"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/%E7%AC%AC14%E7%AB%A0_%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95.jpg" alt="第14章_标记-压缩算法"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418111654087.png" alt="image-20210418111654087"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418111854798.png" alt="image-20210418111854798"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418111920575.png" alt="image-20210418111920575"> </p>
<h1 id="8、小结"><a href="#8、小结" class="headerlink" title="8、小结"></a>8、小结</h1><p><strong>对比三种算法</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418181653720.png" alt="image-20210418181653720">  </p>
<h1 id="9、分代收集算法"><a href="#9、分代收集算法" class="headerlink" title="9、分代收集算法"></a>9、分代收集算法</h1><p><strong>难道就没有一种最优的算法吗？答：没有最优的算法，只有最合适的算法。</strong></p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418182049316.png" alt="image-20210418182049316"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418182216450.png" alt="image-20210418182216450"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418182612553.png" alt="image-20210418182612553"> </p>
<h1 id="X、增量收集算法、分区算法"><a href="#X、增量收集算法、分区算法" class="headerlink" title="X、增量收集算法、分区算法"></a>X、增量收集算法、分区算法</h1><p><strong>增量收集算法</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418183118225.png" alt="image-20210418183118225"> </p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418183448450.png" alt="image-20210418183448450"> </p>
<p><strong>分区算法</strong>：</p>
<p><img src="https://gitee.com/edg7928/jvmnotes/raw/master/15_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/image-20210418183725865.png" alt="image-20210418183725865"> </p>
<p><strong>写在最后</strong>：</p>
<p><strong>注意，这些只是基本的算法思路，实际的GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</strong></p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>上篇：内存与GC</category>
      </categories>
      <tags>
        <tag>JavaJVMNotes</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>


<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>个人博客</title>
    <url>/2021/04/16/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="1-如何部署环境"><a href="#1-如何部署环境" class="headerlink" title="1.如何部署环境"></a>1.如何部署环境</h1><span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 安装环境：nodejs &#x2F; git &#x2F; hexo</span><br><span class="line">1.1 查看node.js的版本：node -v</span><br><span class="line">1.2 查看npm包管理器的版本：npm -v</span><br><span class="line">1.3 查看git版本：git --version</span><br><span class="line">    注：hexo博客框架需要用到nodejs支持</span><br><span class="line">1.4 nodejs淘宝镜像加速器（cnpm）： npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">    查看安装版本：cnpm -v</span><br><span class="line">1.5 全局安装hexo博客框架：cnpm install hexo-cli -g &#x2F; npm install hexo-cli -g</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="2-如何初始化博客"><a href="#2-如何初始化博客" class="headerlink" title="2.如何初始化博客"></a>2.如何初始化博客</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.1 hexo init blog 初始化博客文件夹</span><br><span class="line">2.2 npm install 安装npm依赖项</span><br><span class="line">2.3 hexo server 启动本地预览服务器</span><br><span class="line">2.3 清理缓存：hexo clean（blog目录下）</span><br><span class="line">2.4 生成静态文件：hexo g</span><br><span class="line">2.5 启动博客：hexo s</span><br><span class="line">    一键三联：hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</span><br><span class="line"></span><br><span class="line">注：有关博客的东西都在这个文件夹中生成，如果建立博客过程中出现了错误，直接删掉文件夹，重新来过即可，无需畏惧</span><br></pre></td></tr></table></figure>

<h1 id="3-如何写博客"><a href="#3-如何写博客" class="headerlink" title="3.如何写博客"></a>3.如何写博客</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 新建博客文章：hexo n &quot;博客文章名字&quot;（blog目录下）</span><br><span class="line">2. 编辑的过程：我使用typora进行编辑，vscode进行配置文件的修改</span><br><span class="line">3. 文章存储位置：hexo博客根目录&#x2F;source&#x2F;_posts</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="4-如何把博客部署到远端"><a href="#4-如何把博客部署到远端" class="headerlink" title="4.如何把博客部署到远端"></a>4.如何把博客部署到远端</h1><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">部署到github</span></span><br><span class="line"><span class="number">1.1</span> <span class="string">新建仓库名格式：GitHub用户名.github.io</span></span><br><span class="line"><span class="number">1.2</span> <span class="string">安装部署插件：cnpm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span>  <span class="comment"># npm install hexo --save  安装所有</span></span><br><span class="line"><span class="number">1.3</span> <span class="string">修改_config.yml文件：&quot;:&quot;后边要有空格</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/edg7928/edg7928.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="number">1.4</span>	<span class="string">hexo</span> <span class="string">d</span> <span class="string">推至远端</span></span><br><span class="line">    <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span> <span class="string">安装自动部署发布工具</span></span><br><span class="line">    <span class="string">hexo</span> <span class="string">cl</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">d</span> <span class="string">发布博客，首次发布需要在shell中输入账号和密码。</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">部署到gitee</span></span><br><span class="line"><span class="number">2.1</span> <span class="string">新建仓库名格式:最好与Gitee用户名一样，如果不一样，就会产生二级地址</span></span><br><span class="line"><span class="number">2.2</span> <span class="string">生成ssh公钥，并将密钥进Gitee中，</span></span><br><span class="line">    <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;edg7928&quot;</span></span><br><span class="line">    <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;xuliang7928@163.com&quot;</span></span><br><span class="line">    <span class="string">ssh-keygen</span> <span class="string">-t</span> <span class="string">rsa</span> <span class="string">-C</span> <span class="string">&quot;xuliang7928@163.com&quot;</span></span><br><span class="line"><span class="number">2.3</span> <span class="string">安装部署插件：cnpm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br><span class="line"><span class="number">2.4</span> <span class="string">Gitee</span> <span class="string">Pages：强制Https，开启，以后每次更新博客都要重新</span> <span class="string">更新</span> <span class="string">部署</span></span><br><span class="line">    <span class="string">产生博客免费链接：https://edg7928.gitee.io</span></span><br><span class="line"><span class="number">2.5</span> <span class="string">修改_config.yml文件：</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://gitee.com/edg7928/edg7928.git</span> <span class="comment">## 此为克隆/下载地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://example.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://edg7928.gitee.io</span> <span class="comment">## 此为个人博客链接</span></span><br><span class="line"></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment">## en的时候进入网站会提示是否翻译网页</span></span><br><span class="line"><span class="number">2.6</span>	<span class="string">hexo</span> <span class="string">d</span> <span class="string">推至远端</span></span><br><span class="line">    <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span> <span class="string">安装自动部署发布工具</span></span><br><span class="line">    <span class="string">hexo</span> <span class="string">cl</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">&amp;&amp;</span> <span class="string">hexo</span> <span class="string">d</span> <span class="string">发布博客，首次发布需要在shell中输入账号和密码。</span></span><br></pre></td></tr></table></figure>



<h1 id="5-如何换主题"><a href="#5-如何换主题" class="headerlink" title="5.如何换主题"></a>5.如何换主题</h1><p>主题地址：<a href="https://github.com/litten/hexo-theme-yilia">https://github.com/litten/hexo-theme-yilia</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">修改_config.yml配置文件：</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">主页的菜单：menu</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">source文件夹里生成文件夹tags：hexo</span> <span class="string">n</span> <span class="string">page</span> <span class="string">tages</span></span><br><span class="line"><span class="number">3</span><span class="string">.</span> <span class="string">主题样式更改：scheme</span></span><br><span class="line"><span class="number">4</span><span class="string">.</span> <span class="string">更改头像：avatar</span></span><br><span class="line"><span class="number">5</span><span class="string">.</span> <span class="string">更改标题、作者：在hexo的配置文件里</span> <span class="string">开头修改</span></span><br><span class="line"><span class="number">6</span><span class="string">.</span> <span class="string">启用侧边栏社交链接：social</span></span><br><span class="line"><span class="number">7</span><span class="string">.</span> <span class="string">启动友情链接：links</span></span><br><span class="line"><span class="number">8</span><span class="string">.</span> <span class="string">新建文章：hexo</span> <span class="string">n</span> <span class="string">文件名</span></span><br><span class="line"><span class="number">9</span><span class="string">.</span> <span class="string">文章的书写请见</span>  <span class="string">我的第一篇博客</span></span><br><span class="line"><span class="number">10</span><span class="string">.</span> <span class="string">开启打赏功能：reward</span></span><br><span class="line"><span class="number">11</span><span class="string">.</span> <span class="string">开启阅读全文：auto_excerpt</span></span><br><span class="line"><span class="number">12</span><span class="string">.</span> <span class="string">添加动态背景：canvas</span></span><br><span class="line"><span class="number">13</span><span class="string">.</span> <span class="string">评论系统：valine</span></span><br><span class="line"><span class="number">14</span><span class="string">.</span> <span class="string">加载效果：</span></span><br></pre></td></tr></table></figure>



<h1 id="npm和cnpm"><a href="#npm和cnpm" class="headerlink" title="npm和cnpm"></a>npm和cnpm</h1><h2 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h2><p>1.使用阿里定制的 cnpm 命令行工具代替默认的 npm，输入下面代码进行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>2.检测cnpm版本，如果安装成功可以看到cnpm的基本信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>

<p>3.以后安装插件只需要使用<code>cnpm intall</code>即可</p>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>假如我已经习惯了<code>npm install</code>的安装方式，我不想去下载阿里的cnpm命令工具将命令变成cnpm怎么办？很容易我们想到，我直接将<strong>node的仓库地址改成淘宝镜像的仓库地址</strong>不就好了吗？</p>
<p>1、<strong>临时使用</strong>指定镜像（淘宝）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>2、<strong>永久更改</strong>使用指定镜像（淘宝）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>3、<strong>还原</strong>npm仓库地址，只需再把地址配置成npm镜像就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F; </span><br></pre></td></tr></table></figure>

<p>4、<strong>获取</strong>node仓库地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<h2 id="总结两者区别与联系"><a href="#总结两者区别与联系" class="headerlink" title="总结两者区别与联系"></a>总结两者区别与联系</h2><ul>
<li><p>所以，cnpm安装的的2个模块，两者应该存在引用关系，正常名字模块是非正常名字模块的索引，两者都必须存在才可以使用。但是npm安装下来就不存在这种情况了，因为只有一个正常名字模块。</p>
</li>
<li><p>实测发现，尽管使用npm改成淘宝仓库，发现安装速度还是远远比cnpm慢（当模块比较多的时候）。可能应该和cnpm安装的文件结构有关系吧。</p>
</li>
</ul>
<p>注：详见<a href="https://blog.csdn.net/qq_45216940/article/details/107805484">https://blog.csdn.net/qq_45216940/article/details/107805484</a></p>
]]></content>
      <categories>
        <category>Hexo博客</category>
        <category>初始化</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title>git的autocrlf与safecrlf的相关设置</title>
    <url>/2021/04/18/git%E7%9A%84autocrlf%E4%B8%8Esafecrlf%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>git提交时的文件换行符LF与CRLF的相关问题</p>
<span id="more"></span>
<h1 id="一、AutoCRLF"><a href="#一、AutoCRLF" class="headerlink" title="一、AutoCRLF"></a>一、AutoCRLF</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交时转换为LF，检出时转换为CRLF</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">true</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时转换为LF，检出时不转换</span></span><br><span class="line">git config --global core.autocrlf input   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交检出均不转换</span></span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h1 id="二、SafeCRLF"><a href="#二、SafeCRLF" class="headerlink" title="二、SafeCRLF"></a>二、SafeCRLF</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拒绝提交包含混合换行符的文件</span></span><br><span class="line">git config --global core.safecrlf <span class="literal">true</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许提交包含混合换行符的文件</span></span><br><span class="line">git config --global core.safecrlf <span class="literal">false</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交包含混合换行符的文件时给出警告</span></span><br><span class="line">git config --global core.safecrlf warn</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>CRLF</tag>
        <tag>LF</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2021/02/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h1><span id="more"></span>
<h2 id="第一章节"><a href="#第一章节" class="headerlink" title="第一章节"></a>第一章节</h2><p>内容</p>
<ul>
<li>列表1</li>
<li>列表2<br>  1 子列表<br>  2 子列表2  </li>
<li>列表3</li>
</ul>
<h2 id="第二章节"><a href="#第二章节" class="headerlink" title="第二章节"></a>第二章节</h2><p>内容<br><a href="https://baidu.com/">第一次插入链接</a></p>
<p><img src="https://gitee.com/edg7928/my-images/raw/master/p15829469.jpg" alt="img"></p>
<p><img src="https://gitee.com/edg7928/my-images/raw/master/u=917809301,146704323&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p><img src="/2021/02/22/我的第一篇博客/p15829469.jpg" alt="img"></p>
<p><img src="/2021/02/22/我的第一篇博客/u=917809301,146704323&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<hr>
<hr>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p><strong>字体是变成了粗的</strong><br><code>git push / git pull 代码行</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">asd</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这是代码块，有一点要注意，不要用键盘的tab进行缩进</span></span><br><span class="line">    <span class="comment">// 把站点配置文件 _config.yml 里的 tab_replace 改成四个空格（注意用单引号括起来）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是引用<br>你看<br>是吧</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>后端</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH的公钥和私钥的相关配置</title>
    <url>/2021/04/16/SSH%E7%9A%84%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="如何在一台电脑上同时使用多把SSH密钥"><a href="#如何在一台电脑上同时使用多把SSH密钥" class="headerlink" title="如何在一台电脑上同时使用多把SSH密钥"></a>如何在一台电脑上同时使用多把SSH密钥</h1><span id="more"></span>
<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>最近重装了一下系统，用上了 win10，之前电脑上的开发环境和配置都被清除了，由于工作原因我需要经常使用 Gitee（码云）和 Github ，之前配置好了一个，但是不知道怎么同时配置两个，所以就有了这篇文章。</p>
<p>既然要同时配置 Gitee 和 Github ，所以以下这些步骤自然是要执行两遍的。一般来说，在 Gitee 上和在 Github 上使用的账号邮箱应该是不一样的，所以配置的时候要特别注意一下。</p>
<h2 id="2、清除-git-的全局设置"><a href="#2、清除-git-的全局设置" class="headerlink" title="2、清除 git 的全局设置"></a>2、清除 git 的全局设置</h2><p>如果已经配置Git，需要先清除git 的全局设置，如果没有就跳过这一步。<br><code>git config --global --list</code> 查看是否设置：</p>
<p>删除设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --global --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure>

<p><strong>邮箱不必与GitHub账号相同，个人邮箱即可。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;我的姓名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxxx@qq.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>查看账户和邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name </span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure>



<h2 id="3、创建-ssh-key"><a href="#3、创建-ssh-key" class="headerlink" title="3、创建 ssh key"></a>3、创建 ssh key</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入用户目录下的 .ssh 文件夹下，路径会因你使用的操作系统不同而略有差异</span></span><br><span class="line"><span class="comment"># 没有这个文件夹也无所谓，直接运行下一句命令也可以，再直接一点，直接创建个.ssh的文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 key，将邮件地址替换为你 Gitee 或者 Github 使用的邮件地址</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxx@xxx.com&quot;</span> -f <span class="string">&quot;自定义密钥名称id_rsa&quot;</span></span><br><span class="line">-t  <span class="comment"># 密钥的类型</span></span><br><span class="line">-C  <span class="comment"># 用于识别这个密钥的注释，而且这个注释其实就在 ~\.ssh\id_rsa.pub 文本内容末尾。所以这个注释你可以输入任何内容，很多网站和软件用这个注释作为密钥的名字</span></span><br><span class="line">-f  <span class="comment"># 自定义密钥的名称</span></span><br></pre></td></tr></table></figure>

<p>关于 ssh 参数更多参见：<a href="https://www.iteye.com/blog/killer-jok-1853451">ssh-keygen参数说明</a>。。。。</p>
<p>接下来应该会看到下面的提示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/your_user_name/.ssh/id_rsa): id_rsa_gitee</span><br></pre></td></tr></table></figure>

<p>这一步如果默认回车，会生成名为 <code>id_rsa</code> 的文件，你可以输入不同的名字来便于识别文件，比如生成 Gitee 的 ssh key 可以设置为 <code>id_rsa_gitee</code>，设置 Github 的 ssh key 可以设置为 <code>id_rsa_github</code> ，我这里设置为 <code>id_rsa_gitee</code>。</p>
<p>接下来的会看到：（这里是输入密码）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br></pre></td></tr></table></figure>

<p>直接回车，然后会看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<p>继续回车就行了。生成完毕：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your identification has been saved <span class="keyword">in</span> id_rsa_gitee.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> id_rsa_gitee.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:F0K/ojCbFzgMPru11m4g/9uV03oHK+U0rKBLwOOye2c xxx@xxx.com</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|        .        |</span></span><br><span class="line"><span class="string">|       . .       |</span></span><br><span class="line"><span class="string">|  .     . o      |</span></span><br><span class="line"><span class="string">| . + .   . o     |</span></span><br><span class="line"><span class="string">|  o X . S o.     |</span></span><br><span class="line"><span class="string">|  .+.O o.o o*    |</span></span><br><span class="line"><span class="string">|  oo=o+. .+=.+   |</span></span><br><span class="line"><span class="string">|   =++E. .oo+ .  |</span></span><br><span class="line"><span class="string">|  ++.*=o. .o .   |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure>

<h2 id="4、在-Gitee-和-Github-添加-public-key"><a href="#4、在-Gitee-和-Github-添加-public-key" class="headerlink" title="4、在 Gitee 和 Github 添加 public key"></a>4、在 Gitee 和 Github 添加 public key</h2><p>找到用户目录下的 .ssh 文件夹，查看并复制创建好的 <code>id_rsa_gitee.pub</code> 或 <code>id_rsa_github.pub</code> 的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="comment"># 查看 id_rsa_gitee.pub 文件内容</span></span><br><span class="line">cat id_rsa_gitee.pub</span><br></pre></td></tr></table></figure>

<p>会显示这样一串东西，复制它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDZbvgUEj3XAXH4HkW27ibdXgV6VHdrA9/WdSDHtiiC55mjPvxj3OtPxIbpeJmhWyHiJWR6</span><br><span class="line">uUuK+gkb//O51uWCPhHqxKR7+45tZ9jHqXW+hEKPp+odQgc+3hiHAjTkn3JGeIJlQp2UdJCDHBrp+kcgVeg91+y7cU3ufaUQ/hpD</span><br><span class="line">rCgn6uvwjwJgnDhV9DYi+gFUFe7LUwa1o4nfwg43ycuOOuT7c6VO2dj/0pLRUVTPQYu/C3kaaPVedir7mKIu/dM6Ec44bhYTp1Dq</span><br><span class="line">qp8BO42Cfo+n+dempqYTe2wcPvuDjSj884IATc/KvBfc86Yd2Uj7NI7li90Y3i6adoxUIWQh xxx@xxx.com</span><br></pre></td></tr></table></figure>

<p>打开 Gitee 和 Github 的网站找到设置，再找到 SSH Keys，添加复制的 public key 。</p>
<p><img src="https://pic4.zhimg.com/80/v2-a434314dbe62d64fb1942493555fc2f7_720w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-c97914c848e5485f2e79f6e7a68a29b8_720w.jpg" alt="img"></p>
<h2 id="5、添加私钥："><a href="#5、添加私钥：" class="headerlink" title="5、添加私钥："></a>5、添加私钥：</h2><p>默认只读取 id_rsa，为了让 SSH 识别新的私钥，需要将新的私钥加入到 SSH agent 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id-rsa <span class="comment"># ~ 代表.ssh所在目录路径</span></span><br></pre></td></tr></table></figure>

<p>如果执行ssh-add时提示”Could not open a connection to your authentication agent”，可以现执行命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-agent bash</span><br><span class="line"><span class="comment"># 然后再运行ssh-add命令。</span></span><br><span class="line"><span class="comment"># 可以通过 ssh-add -l 来确私钥列表</span></span><br><span class="line">$ ssh-add -l</span><br><span class="line"><span class="comment"># 可以通过 ssh-add -D 来清空私钥列表</span></span><br><span class="line">$ ssh-add -D</span><br><span class="line"></span><br><span class="line"><span class="comment">## 可以用于加密私钥，不用每次都输入私钥密码</span></span><br><span class="line">$ ssh-keygen -p  <span class="comment"># 用来修改密码</span></span><br></pre></td></tr></table></figure>
<p><strong>上边是临时的</strong>：</p>
<h2 id="6、创建配置文件："><a href="#6、创建配置文件：" class="headerlink" title="6、创建配置文件："></a>6、创建配置文件：</h2><p>**多账号必须配置 config 文件(重点)**：</p>
<p>若.ssh目录下无 config 文件，则需创建 config 文件</p>
<p>在 .ssh 文件夹中创建 <strong>config</strong> 文件，添加以下内容以区分多个 ssh key：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gitee</span></span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/sxl_id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/sxl_id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># coding</span></span><br><span class="line">Host e.coding.net</span><br><span class="line">HostName e.coding.net</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/sxl_id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># codeup</span></span><br><span class="line">Host codeup.aliyun.com</span><br><span class="line">HostName codeup.aliyun.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/sxl_id_rsa <span class="comment"># 路径下密钥的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相关参数设定</span></span><br><span class="line">Host</span><br><span class="line">它涵盖了下面一个段的配置，我们可以通过他来替代将要连接的服务器地址。</span><br><span class="line">这里可以使用任意字段或通配符。当ssh的时候如果服务器地址能匹配上这里Host指定的值，则Host下面指定的HostName将被作为最终的服务器地址使用，并且将使用该Host字段下面配置的所有自定义配置来覆盖默认的配置信息。</span><br><span class="line">HostName</span><br><span class="line">真正连接的服务器地址</span><br><span class="line">PreferredAuthentications</span><br><span class="line">指定优先使用哪种方式验证，支持密码和秘钥验证方式</span><br><span class="line">IdentityFile</span><br><span class="line">指定本次连接使用的密钥文件</span><br><span class="line">Port</span><br><span class="line">自定义的端口。默认为22，可不配置</span><br><span class="line">User</span><br><span class="line">自定义的用户名，默认为git，可不配置</span><br></pre></td></tr></table></figure>

<h2 id="7、测试连接是否正常"><a href="#7、测试连接是否正常" class="headerlink" title="7、测试连接是否正常"></a>7、测试连接是否正常</h2><p>在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com // 这个T必须大写</span><br></pre></td></tr></table></figure>

<p>若返回如下内容，则 Github 连接正常：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hi edg7928! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

<p>继续在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@gitee.com</span><br></pre></td></tr></table></figure>

<p>若返回如下内容，则 Gitee 连接正常。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hi edg7928! You<span class="string">&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access.</span></span><br></pre></td></tr></table></figure>
<p>继续在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@codeup.aliyun.com</span><br></pre></td></tr></table></figure>
<p>若返回如下内容，则 CodeUP 连接正常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome to CodeUP, edg7928!</span><br></pre></td></tr></table></figure>

<p>（完）</p>
<h1 id="如何在多个平台使用同一把SSH密钥"><a href="#如何在多个平台使用同一把SSH密钥" class="headerlink" title="如何在多个平台使用同一把SSH密钥"></a>如何在多个平台使用同一把SSH密钥</h1><h2 id="1、配置ssh账户和邮箱"><a href="#1、配置ssh账户和邮箱" class="headerlink" title="1、配置ssh账户和邮箱"></a>1、配置ssh账户和邮箱</h2><p><strong>邮箱不必与GitHub账号相同，个人邮箱即可。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;我的姓名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxxx@qq.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>查看账户和邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure>

<h2 id="2、本地生成ssh公钥"><a href="#2、本地生成ssh公钥" class="headerlink" title="2、本地生成ssh公钥"></a>2、本地生成ssh公钥</h2><p>邮箱为刚配置好的账户邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxx@xxxxx.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>按照提示完成三次回车，即可生成 ssh key</p>
<h2 id="3、查看ssh公钥"><a href="#3、查看ssh公钥" class="headerlink" title="3、查看ssh公钥"></a>3、查看ssh公钥</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<h2 id="4、复制公钥到GitHub、gitlab、码云上"><a href="#4、复制公钥到GitHub、gitlab、码云上" class="headerlink" title="4、复制公钥到GitHub、gitlab、码云上"></a>4、复制公钥到GitHub、gitlab、码云上</h2><p><strong>三个平台可以使用一个公钥，还需要配置config文件</strong></p>
<h2 id="5、测试是否连接成功"><a href="#5、测试是否连接成功" class="headerlink" title="5、测试是否连接成功"></a>5、测试是否连接成功</h2><p>码云</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@gitee.com</span><br><span class="line">Hi menglinjie! You<span class="string">&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access.表示连接成功 </span></span><br></pre></td></tr></table></figure>

<p>github</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi menglinjie! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.表示连接成功。</span></span><br></pre></td></tr></table></figure>

<h1 id="SSH密钥的相关说明"><a href="#SSH密钥的相关说明" class="headerlink" title="SSH密钥的相关说明"></a>SSH密钥的相关说明</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>密钥对：</strong>在非对称加密技术中，有两种密钥，分为私钥和公钥，私钥是密钥对所有者持有，不可公布，公钥是密钥对持有者公布给他人的。<br><strong>公钥：</strong>公钥用来给数据加密，用公钥加密的数据只能使用私钥解密<br><strong>私钥：</strong>如上，用来解密公钥加密的数据。<br><strong>摘要（digest）：</strong>对需要传输的文本，做一个HASH计算，一般采用SHA1，SHA2来获得<br><strong>签名（signature）：</strong>使用私钥对需要传输的文本的摘要进行加密，得到的密文即被称为该次传输过程的签名。（看最下面的一部分就明白了）<br><strong>签名验证</strong>：数据接收端，拿到传输文本，但是需要确认该文本是否就是发送者发出的内容，中途是否曾经被篡改。因此拿自己持有的公钥对签名进行解密（密钥对中的一种密钥加密的数据必定能使用另一种密钥解密。），得到了文本的摘要，然后使用与发送方同样的HASH算法计算接收到的文本的摘要值，再与解密得到的摘要做对比，发现二者完全一致，则说明文本没有被篡改过。<br><strong>加密：</strong>是将数据资料加密，使得非法用户即使取得加密过的资料，也无法获取正确的资料内容，所以数据加密可以保护数据，防止监听攻击。其重点在于数据的安全性。</p>
<h2 id="密钥分类"><a href="#密钥分类" class="headerlink" title="密钥分类"></a>密钥分类</h2><p><strong>对称密钥加密</strong>：又称私钥加密或会话密钥加密算法，即信息的发送方和接收方使用同一个密钥去加密和解密数据。它的<strong>最大优势</strong>是加/解密<strong>速度快</strong>，适合于对大数据量进行加密，<strong>但密钥管理困难</strong>。</p>
<p>非对称密钥加密系统，又称<strong>公钥密钥加密</strong>：它需要使用不同的密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，但加密和解密<strong>速度却</strong>比对称密钥加密<strong>慢得多</strong>。</p>
<p>在现代密码体制中加密和解密是采用不同的密钥（公开密钥），也就是非对称密钥密码系统，每个通信方均需要两个密钥，即公钥和私钥，这两把密钥可以互为加解密。公钥是公开的，不需要保密，而私钥是由个人自己持有，并且必须妥善保管和注意保密。公钥私钥的原则：</p>
<ol>
<li><strong>一个公钥对应一个私钥</strong>。</li>
<li><strong>密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥</strong>。</li>
<li><strong>如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密</strong>。</li>
<li><strong>如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密</strong>。</li>
</ol>
<p>　　非对称密钥密码的主要应用就是<strong>公钥加密和公钥认证</strong>，而公钥加密的过程和公钥认证的过程是不一样的，下面我就详细讲解一下两者的区别，详情请见相关文献1、2。</p>
<h3 id="公开密钥加密过程"><a href="#公开密钥加密过程" class="headerlink" title="公开密钥加密过程"></a>公开密钥加密过程</h3><p>　　比如有两个用户Alice和Bob，Alice想把一段明文通过双钥加密的技术发送给Bob，Bob有一对公钥和私钥，那么加密解密的过程如下：</p>
<ol>
<li><strong>Bob将他的公开密钥传送给Alice</strong>。</li>
<li><strong>Alice用Bob的公开密钥加密她的消息，然后传送给Bob</strong>。</li>
<li><strong>Bob用他的私人密钥解密Alice的消息</strong>。</li>
</ol>
<p>总结：<strong>Alice使用Bob的公钥进行加密，Bob用自己的私钥进行解密</strong>。</p>
<h3 id="公开密钥认证过程"><a href="#公开密钥认证过程" class="headerlink" title="公开密钥认证过程"></a>公开密钥认证过程</h3><p>　　身份认证和加密就不同了，主要用于<strong>鉴别用户的真伪</strong>。这里我们只要能够鉴别一个用户的私钥是正确的，就可以鉴别这个用户的真伪。</p>
<p>　　还是Alice和Bob这两个用户，Alice想让Bob知道自己是真实的Alice，而不是假冒的，因此Alice只要使用公钥密码学对文件签名发送给Bob，Bob使用Alice的公钥对文件进行解密，如果可以解密成功，则证明Alice的私钥是正确的，因而就完成了对Alice的身份鉴别。整个身份认证的过程如下：</p>
<ol>
<li><strong>Alice用她的私人密钥对文件加密，从而对文件签名</strong>。</li>
<li><strong>Alice将签名的文件传送给Bob</strong>。</li>
<li><strong>Bob用Alice的公钥解密文件，从而验证签名</strong>。</li>
</ol>
<p>总结：<strong>Alice使用自己的私钥加密，Bob用Alice的公钥进行解密</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>密钥指的是私钥或者公钥—&gt;密钥=私钥/公钥；</li>
<li>密钥对，针对的是非对称加密—&gt;密钥对=私钥+公钥</li>
</ol>
<p>既然是加密,肯定是不希望别人知道我的消息,所以只要我才能解密 ，所以得出,<strong>公钥负责加密,私钥负责解密</strong>, <strong>同理,既然是签名,那肯定是不希望有人冒充我发消息,只有我才能发布这个签名, 所以得出,私钥负责签名,公钥负责验证</strong></p>
<p>那么这里一共有两组四个密钥：<br>A的公钥（PUB_A），A的私钥（PRI_A）；B的公钥（PUB_B），B的私钥（PRI_B）。</p>
<p><strong>公钥一般用来加密，私钥用来签名</strong>。通常公钥是公开出去的，但是私钥只能自己私密持有。公钥和私钥唯一对应，用某个公钥签名过得内容只能用对应的私钥才能解签验证；<strong>同样用某个私钥加密的内容只能用对应的公钥才能解密</strong>。<br>这时A向B发送信息的整个签名和加密的过程如下：</p>
<ol>
<li>A先用自己的私钥（PRI_A）对信息（一般是信息的摘要）进行签名。</li>
<li>A接着使用B的公钥（PUB_B）对信息内容和签名信息进行加密。</li>
</ol>
<p>这样当B接收到A的信息后，获取信息内容的步骤如下：</p>
<ol>
<li>B用自己的私钥（PRI_B）解密A用B的公钥（PUB_B）加密的内容</li>
<li>B得到解密后的明文后用A的公钥（PUB_A）解签A用A自己的私钥（PRI_A）的签名。</li>
</ol>
<p>从而整个过程就保证了开始说的端到端的唯一确认。A的签名只有A的公钥才能解签，这样B就能确认这个信息是A发来的；A的加密只有B的私钥才能解密，这样A就能确认这份信息只能被B读取。</p>
<p>SSH公钥也有安全隐患：如果请求被劫持，接收到假的公钥，然而用户还将此公钥当成真的公钥，那就把信息传给了坏人</p>
<p><strong>总结：</strong>公钥和私钥是成对的，它们互相解密（密钥指公钥或私钥，密钥对指公钥加私钥）。</p>
<p><strong>公钥和私钥都可以加密和解密</strong>。</p>
<p><strong>私钥数字签名，公钥验证</strong>。</p>
<p>（如下图）</p>
<p><img src="https://img-blog.csdn.net/20180608110633762?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5odWFucTEyMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190305150104217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTg2Mjgw,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="SSH使用的图示过程"><a href="#SSH使用的图示过程" class="headerlink" title="SSH使用的图示过程"></a>SSH使用的图示过程</h2><p>\1. 鲍勃有两把钥匙，一把是公钥，另一把是私钥。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey1.png" alt="PubKey1"></p>
<p>\2. 鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey2.png" alt="PubKey2"></p>
<p>\3. 苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey3.png" alt="PubKey3"></p>
<p>\4. 鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey4.png" alt="PubKey4"></p>
<p>\5. 鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey5.png" alt="PubKey5"></p>
<p>\6. 然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey6.png" alt="PubKey6"></p>
<p>\7. 鲍勃将这个签名，附在信件下面，一起发给苏珊。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey7.png" alt="PubKey7"></p>
<p>\8. 苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey8.png" alt="PubKey8"></p>
<p>\9. 苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey9.png" alt="PubKey9"></p>
<p>\10. 复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey10.png" alt="PubKey10"></p>
<p>\11. 后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Di<a href="http://www.linuxprobe.com/chapter-21/">git</a>al Certificate）。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey11.png" alt="PubKey11"></p>
<p>\12. 鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey12.png" alt="PubKey12"></p>
<p>\13. 苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey13.png" alt="PubKey13"></p>
<p>\14. 下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey14.jpg" alt="PubKey14"></p>
<p>\15. 首先，客户端向服务器发出加密请求。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey15.png" alt="PubKey15"></p>
<p>\16. 服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey16.png" alt="PubKey16"></p>
<p>\17. 客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey17.png" alt="PubKey17"></p>
<p>\18. 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey18.png" alt="PubKey18"></p>
<p>\19. 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。<br><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey19.jpg" alt="PubKey19"></p>
<p><img src="http://www.linuxprobe.com/wp-content/uploads/2016/04/PubKey20.png" alt="PubKey20"></p>
<h2 id="相关文献"><a href="#相关文献" class="headerlink" title="相关文献"></a>相关文献</h2><p>1、linux中公钥和私钥的区别以及关系：<a href="https://blog.csdn.net/gui951753/article/details/79252773">https://blog.csdn.net/gui951753/article/details/79252773</a></p>
<p>2、SSH 公钥 私钥的理解：<a href="https://zhuanlan.zhihu.com/p/134349361">https://zhuanlan.zhihu.com/p/134349361</a></p>
]]></content>
      <categories>
        <category>Hexo博客</category>
        <category>SSH免密登录</category>
      </categories>
      <tags>
        <tag>Hexo博客</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>树（数据结构）</title>
    <url>/2021/03/29/%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树遍历系列总结"><a href="#二叉树遍历系列总结" class="headerlink" title="二叉树遍历系列总结"></a>二叉树遍历系列总结</h1><p>这里分别给出了三种二叉树的遍历方法与N叉树的前序遍历，及其时空复杂度<br>1：递归：直接递归版本、针对不同题目通用递归版本（包括前序、中序、后序）<br>2：迭代：最常用版本（常用主要包括前序和层序，即【DFS和BFS】）、【前中后】序遍历通用版本（一个栈的空间）、【前中后层】序通用版本（双倍栈（队列）的空间）<br>3：莫里斯遍历：利用线索二叉树的特性进行遍历<br>4：N叉树的前序遍历</p>
<span id="more"></span>

<p>LeeCode题目链接：<br>144. 二叉树的前序遍历</p>
<ol start="145">
<li><p>二叉树的中序遍历</p>
</li>
<li><p>二叉树的后序遍历</p>
</li>
<li><p>二叉树的层序遍历</p>
</li>
<li><p>N叉树的前序遍历</p>
</li>
</ol>
<p><strong>注：</strong>前序遍历与后序遍历要有一种<strong>翻转</strong>的思想在里面，<strong>前序</strong>遍历是<strong>根左右</strong>，<strong>后序</strong>遍历是<strong>左右根</strong>，可揣摩<strong>右左根、根右左</strong>，所以前序遍历和后序遍历的方法是<strong>通用</strong>的，<strong>区别</strong>是一个<strong>先往左</strong>子树遍历，另一个是<strong>先往右</strong>子树遍历。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：空间复杂度：O(h)，h为树的高度。最坏情况下需要空间O(n)，平均情况为O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归1：二叉树遍历最易理解和实现版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 前序递归</span></span><br><span class="line">        <span class="keyword">return</span> [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)</span><br><span class="line">        <span class="comment"># # 中序递归 </span></span><br><span class="line">        <span class="comment"># return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span></span><br><span class="line">        <span class="comment"># # 后序递归</span></span><br><span class="line">        <span class="comment"># return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span>      </span><br><span class="line">            <span class="comment"># 前序递归</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            dfs(cur.left)</span><br><span class="line">            dfs(cur.right) </span><br><span class="line">            <span class="comment"># # 中序递归</span></span><br><span class="line">            <span class="comment"># dfs(cur.left)</span></span><br><span class="line">            <span class="comment"># res.append(cur.val)</span></span><br><span class="line">            <span class="comment"># dfs(cur.right)</span></span><br><span class="line">            <span class="comment"># # 后序递归</span></span><br><span class="line">            <span class="comment"># dfs(cur.left)</span></span><br><span class="line">            <span class="comment"># dfs(cur.right)</span></span><br><span class="line">            <span class="comment"># res.append(cur.val)      </span></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(h)，h为树的高度。取决于树的结构，最坏情况存储整棵树，即O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代1：前序遍历最常用模板（后序同样可以用）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []        </span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="comment"># # 前序迭代模板：最常用的二叉树DFS迭代遍历模板</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># # 后序迭代，相同模板：将前序迭代进栈顺序稍作修改，最后得到的结果反转</span></span><br><span class="line">        <span class="comment"># while stack:</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     if cur.left:</span></span><br><span class="line">        <span class="comment">#         stack.append(cur.left)</span></span><br><span class="line">        <span class="comment">#     if cur.right:</span></span><br><span class="line">        <span class="comment">#         stack.append(cur.right)</span></span><br><span class="line">        <span class="comment">#     res.append(cur.val)</span></span><br><span class="line">        <span class="comment"># return res[::-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代1：层序遍历最常用模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        cur, res = [root], []</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            lay, layval = [], []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> cur:</span><br><span class="line">                layval.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: lay.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: lay.append(node.right)</span><br><span class="line">            cur = lay</span><br><span class="line">            res.append(layval)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># 迭代2：前、中、后序遍历通用模板（只需一个栈的空间）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span> </span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="comment"># 中序，模板：先用指针找到每颗子树的最左下角，然后进行进出栈操作</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># # 前序，相同模板</span></span><br><span class="line">        <span class="comment"># while stack or cur:</span></span><br><span class="line">        <span class="comment">#     while cur:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment">#         stack.append(cur)</span></span><br><span class="line">        <span class="comment">#         cur = cur.left</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     cur = cur.right</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># # 后序，相同模板</span></span><br><span class="line">        <span class="comment"># while stack or cur:</span></span><br><span class="line">        <span class="comment">#     while cur:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment">#         stack.append(cur)</span></span><br><span class="line">        <span class="comment">#         cur = cur.right</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     cur = cur.left</span></span><br><span class="line">        <span class="comment"># return res[::-1]</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代3：标记法迭代（需要双倍的空间来存储访问状态）：</span></span><br><span class="line"><span class="comment"># 前、中、后、层序通用模板，只需改变进栈顺序或即可实现前后中序遍历，</span></span><br><span class="line"><span class="comment"># 而层序遍历则使用队列先进先出。0表示当前未访问，1表示已访问。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = [(<span class="number">0</span>, root)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            flag, cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 前序，标记法</span></span><br><span class="line">                stack.append((<span class="number">0</span>, cur.right))</span><br><span class="line">                stack.append((<span class="number">0</span>, cur.left))</span><br><span class="line">                stack.append((<span class="number">1</span>, cur))</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># # 后序，标记法</span></span><br><span class="line">                <span class="comment"># stack.append((1, cur))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.right))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.left))</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># # 中序，标记法</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.right))</span></span><br><span class="line">                <span class="comment"># stack.append((1, cur))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.left))  </span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur.val)  </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># # 层序，标记法</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># queue = [(0, root)]</span></span><br><span class="line">        <span class="comment"># while queue:</span></span><br><span class="line">        <span class="comment">#     flag, cur = queue.pop(0)  # 注意是队列，先进先出</span></span><br><span class="line">        <span class="comment">#     if not cur: continue</span></span><br><span class="line">        <span class="comment">#     if flag == 0:</span></span><br><span class="line">                  <span class="comment"># 层序遍历这三个的顺序无所谓，因为是队列，只弹出队首元素</span></span><br><span class="line">        <span class="comment">#         queue.append((1, cur))</span></span><br><span class="line">        <span class="comment">#         queue.append((0, cur.left))</span></span><br><span class="line">        <span class="comment">#         queue.append((0, cur.right))</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 莫里斯遍历</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，看似超过O(n)，有的节点可能要访问两次，实际分析还是O(n)，具体参考大佬博客的分析。</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)，如果在遍历过程中就输出节点值，则只需常数空间就能得到中序遍历结果，空间只需两个指针。</span></span><br><span class="line"><span class="comment"># 如果将结果储存最后输出，则空间复杂度还是O(n)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PS：莫里斯遍历实际上是在原有二叉树的结构基础上，构造了线索二叉树，</span></span><br><span class="line"><span class="comment"># 线索二叉树定义为：原本为空的右子节点指向了中序遍历顺序之后的那个节点，把所有原本为空的左子节点都指向了中序遍历之前的那个节点</span></span><br><span class="line"><span class="comment"># emmmm，好像大学教材学过，还考过</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处只给出中序遍历，前序遍历只需修改输出顺序即可</span></span><br><span class="line"><span class="comment"># 而后序遍历，由于遍历是从根开始的，而线索二叉树是将为空的左右子节点连接到相应的顺序上，使其能够按照相应准则输出</span></span><br><span class="line"><span class="comment"># 但是后序遍历的根节点却已经没有额外的空间来标记自己下一个应该访问的节点，</span></span><br><span class="line"><span class="comment"># 所以这里需要建立一个临时节点dump，令其左孩子是root。并且还需要一个子过程，就是倒序输出某两个节点之间路径上的各个节点。</span></span><br><span class="line"><span class="comment"># 具体参考大佬博客</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 莫里斯遍历，借助线索二叉树中序遍历（附前序遍历）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># cur = pre = TreeNode(None)</span></span><br><span class="line">        cur = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                <span class="comment"># print(cur.val)</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right <span class="keyword">and</span> pre.right != cur:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre.right:</span><br><span class="line">                    <span class="comment"># print(cur.val) 这里是前序遍历的代码，前序与中序的唯一差别，只是输出顺序不同</span></span><br><span class="line">                    pre.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.right = <span class="literal">None</span></span><br><span class="line">                    res.append(cur.val)</span><br><span class="line">                    <span class="comment"># print(cur.val)</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树遍历</span></span><br><span class="line"><span class="comment"># 时间复杂度：时间复杂度：O(M)，其中 M 是 N 叉树中的节点个数。每个节点只会入栈和出栈各一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(M)。在最坏的情况下，这棵 N 叉树只有 2 层，所有第 2 层的节点都是根节点的孩子。</span></span><br><span class="line"><span class="comment"># 将根节点推出栈后，需要将这些节点都放入栈，共有 M−1个节点，因此栈的大小为 O(M)。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树简洁递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = [root.val]</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> root.children:</span><br><span class="line">            res.extend(self.preorder(node))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树通用递归模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">                helper(child)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树迭代方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        s = [root]</span><br><span class="line">        <span class="comment"># s.append(root)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> s:</span><br><span class="line">            node = s.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="comment"># for child in node.children[::-1]:</span></span><br><span class="line">            <span class="comment">#     s.append(child)</span></span><br><span class="line">            s.extend(node.children[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：<span class="number">821218213</span></span><br><span class="line">链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/python3-er-cha-shu-suo-you-bian-li-mo-ban-ji-zhi-s/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>


<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>刷完整个<strong>二叉树</strong>专题，再去做什么<strong>回溯动规分治</strong>专题，你就会发现<strong>只要涉及递归</strong>的问题，<strong>都是树</strong>的问题。</p>
<p><strong>为什么</strong>要先刷二叉树呢，<strong>因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题</strong>。</p>
<p><strong>快速排序</strong>就是个二叉树的<strong>前序遍历</strong>，<strong>归并排序</strong>就是个二叉树的<strong>后序遍历</strong>。</p>
<ol>
<li><p>前序遍历：根、左、右。</p>
</li>
<li><p>后序遍历：左、右、根。</p>
</li>
<li><p>中序遍历：左、根、右。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>层次遍历：</p>
<p><strong>核心思想</strong>：每次<strong>出队一个</strong>元素，就将<strong>该元素的孩子节点加入</strong>队列中，<strong>直至</strong>队列中元素<strong>个数为0</strong>时，<strong>出队的顺序</strong>就是该二叉树的<strong>层次遍历结果</strong>。</p>
<p><strong>1. 初始状态下，队列中只保留根节点的元素</strong>：</p>
<p><img src="https://gitee.com/edg7928/my-images/raw/master/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5qaW5kb25nMDgwNA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>2. 当A出队时，将A的孩子节点加入队列中：</strong></p>
<p><img src="https://gitee.com/edg7928/my-images/raw/master/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLm=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>3.重复上面的动作，队首元素出队时，将孩子节点加入队尾…….</strong></p>
<p><img src="https://gitee.com/edg7928/my-images/raw/master/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW5qaWlor_FFFFFF,t_70" alt="img"></p>
<p><img src="https://gitee.com/edg7928/my-images/raw/master/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHnMDgwNA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://gitee.com/edg7928/my-images/raw/master/kb25nMDgwNA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>………..</p>
</li>
</ol>
<p>##队列</p>
<p>队列Queue</p>
<p>**1. 元素的增、删、查 (抛出异常Exception)**：<br>add          增加一个元索      如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br>remove   移除并返回队列头部的元素     如果队列为空，则抛出一个NoSuchElementException异常<br>element  返回队列头部的元素     如果队列为空，则抛出一个NoSuchElementException异常</p>
<p>**2. 元素的增、删、查 (返回特定值)**：<br>offer        添加一个元素并返回true      如果队列已满，则返回false<br>poll          移除并返问队列头部的元素     如果队列为空，则返回null<br>peek        返回队列头部的元素       如果队列为空，则返回null</p>
<p>**3. 元素的增、删 (阻塞)**：<br>put          添加一个元素      如果队列满，则阻塞<br>take        移除并返回队列头部的元素     如果队列为空，则阻塞</p>
<p><strong>4. 其他</strong>：</p>
<p>size          队列中元素个数<br>isEmpty   队列是否为空</p>
<h2 id="高度、深度"><a href="#高度、深度" class="headerlink" title="高度、深度"></a>高度、深度</h2><p><img src="https://gitee.com/edg7928/my-images/raw/master/1601643551-slRuDJ-110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%912.png" alt="110.平衡二叉树2.png"></p>
<p>因为求<strong>深度</strong>可以<strong>从上到下</strong>去查 所以需要<strong>前序遍历（根左右）</strong>，而<strong>高度</strong>只能<strong>从下到上</strong>去查，所以只能<strong>后序遍历（左右根）</strong>。</p>
<p>为什么<strong>104</strong><a href="https://mp.weixin.qq.com/s/guKwV-gSNbA1CcbvkMtHBg">二叉树：看看这些树的最大深度</a>中求的是二叉树的最大深度，也用的是后序遍历。</p>
<p>那是因为代码的逻辑其实是求的根节点的高度，而<strong>根节点的高度</strong>就是这颗<strong>树的最大深度</strong>，所以才可以使用后序遍历。</p>
<h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p><strong>类似于</strong>树的前序遍历的推广，首先以一个未被访问过的顶点作为起始顶点，沿当前顶点的边走到未访问过的顶点；当没有未访问过的顶点时，则回到上一个顶点，继续试探别的顶点，直至所有的顶点都被访问过。</p>
<p><strong>深度</strong>优先遍历用的是<strong>栈</strong>，而<strong>广度</strong>优先遍历要用<strong>队列</strong>来实现。</p>
<p><strong>1. 递归</strong>实现：递归的表达性很好，也很容易理解，不过如果<strong>层级过深</strong>，很容易导致<strong>栈溢出</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 非递归</strong>实现：</p>
<h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p><strong>类似于</strong>树的层次遍历，<strong>指的是</strong>从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。</p>
<p><strong>深度</strong>优先遍历用的是<strong>栈</strong>，而<strong>广度</strong>优先遍历要用<strong>队列</strong>来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll(); <span class="comment">// Java 的 pop 写作 poll()</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要用于<strong>层序遍历</strong>和<strong>最短路径</strong>问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树的层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            <span class="comment">// 变量 i 无实际意义，只是为了循环 n 次</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>写递归算法的<strong>关键</strong>是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，<strong>绝不要跳入递归的细节</strong>。</p>
<p><strong>写树相关的算法，简单说就是，先搞清楚当前</strong> <strong><code>root</code></strong> <strong>节点该做什么，然后根据函数定义递归调用子节点</strong>，递归调用会<strong>让孩子节点做相同的事情</strong>。然后根据题目要求选择使用前序，中序，后续的递归框架。二叉树的问题难点在于，<strong>如何把题目的要求细化成每个节点需要做的事情</strong>。</p>
<p>递归是遍历的<strong>实现方式</strong>，<strong>不要</strong>把递归和遍历方式<strong>等同</strong>。。</p>
<p><strong>递归与迭代的区别</strong>：递归是自己调用自己，每次旨在缩小问题规模。迭代是自己执行很多次，每次旨在更接近目标。</p>
<ol>
<li><strong>参数和返回值</strong>：应该给上一级返回什么信息？</li>
<li><strong>终止条件</strong>：递归应该在什么时候结束？</li>
<li><strong>单层递归逻辑</strong>：在这一级递归中，应该完成什么任务？</li>
</ol>
<p>注：书写递归函数，<strong>千万不要</strong>纠结于<strong>每一层</strong>之间如何传递返回值，<strong>重点是</strong>专注于当前这一层需要完成什么。</p>
<p><img src="https://gitee.com/edg7928/my-images/raw/master/image-20210329214430553.png" alt="image-20210329214430553"></p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p><strong>中序</strong>遍历思路：每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。</p>
<blockquote>
<p>栈S;<br>p= root;<br>while(p || S不空){<br>    while(p){<br>        p入S;<br>        p = p的左子树;<br>    }<br>    p = S.top 出栈;<br>    访问p;<br>    p = p的右子树;<br>}</p>
<p>作者：jason-2<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/die-dai-fa-by-jason-2/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/die-dai-fa-by-jason-2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p><strong>前序</strong>遍历思路：在迭代算法中，思路演变成，每到一个节点 A，就应该立即访问它。因为，每棵子树都先访问其根节点。对节点的左右子树来说，也一定是先访问根。在 A 的两棵子树中，遍历完左子树后，再遍历右子树。因此，在访问完根节点后，遍历左子树前，要将右子树压入栈。</p>
<blockquote>
<p>栈S;<br>p= root;<br>while(p || S不空){<br>    while(p){<br>        访问p节点；<br>        p的右子树入S;<br>        p = p的左子树;<br>    }<br>    p = S栈顶弹出;<br>}</p>
</blockquote>
<p><strong>后序</strong>遍历思路：每到一个节点 <code>A</code>，就应该立即访问它。 然后将左子树压入栈，再次遍历右子树。遍历完整棵树后，结果序列逆序即可。</p>
<blockquote>
<p>栈S;<br>p= root;<br>while(p || S不空){<br>    while(p){<br>        访问p节点；<br>        p的左子树入S;<br>        p = p的右子树;<br>    }<br>    p = S栈顶弹出;<br>}<br>结果序列逆序;</p>
</blockquote>
<h2 id="094-二叉树的中序遍历"><a href="#094-二叉树的中序遍历" class="headerlink" title="094.二叉树的中序遍历"></a>094.二叉树的中序遍历</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
<p><img src="/2021/03/29/树/..%5C%E9%99%84%E4%BB%B6%5Cinorder_1.jpg" alt="img"></p>
<p><code>输入：root = [1,null,2,3] 输出：[1,3,2]</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> list; &#125;</span><br><span class="line">        inorderTraversal(root.left); <span class="comment">// 左</span></span><br><span class="line">        list.add(root.val); <span class="comment">// 中</span></span><br><span class="line">        inorderTraversal(root.right); <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：迭代 -- 辅助栈迭代 -- 中序遍历1</span></span><br><span class="line"><span class="comment">// 递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123; <span class="comment">// 先遍历左子树，扔入栈</span></span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123; <span class="comment">// 栈中不空，循环不断</span></span><br><span class="line">            root = stack.pop(); <span class="comment">// 根节点出栈</span></span><br><span class="line">            list.add(root.val); <span class="comment">// 列表中添加节点值</span></span><br><span class="line">            root = root.right;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123; <span class="comment">// 遍历右子树</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二：迭代 -- 辅助栈迭代 -- 中序遍历2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 新建栈</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123; <span class="comment">// 循环条件</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123; <span class="comment">// 先把根节点和左节点依次 先扔进栈中</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left; <span class="comment">// 循环完毕，栈顶存的是左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop(); <span class="comment">// 将节点依次从栈中弹出</span></span><br><span class="line">            list.add(root.val); <span class="comment">// 将节点值依次存入列表中</span></span><br><span class="line">            root = root.right; <span class="comment">// 将节点指向其右节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三：莫里斯遍历 / morris遍历</span></span><br><span class="line"><span class="comment">/* 用递归和迭代的方式都使用了辅助的空间，而莫里斯遍历的优点是没有使用任何辅助空间。缺点是改变了整个树的结构，强行把一棵二叉树改成一段链表结构。morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。建立一种机制，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 算法步骤： 后序遍历</span></span><br><span class="line"><span class="comment">1. 如果当前节点的左子节点为空时，输出当前节点，并将当前节点置为该节点的右子节点；</span></span><br><span class="line"><span class="comment">2. 如果当前节点的左子节点不为空，找到当前节点左子树的最右节点（该节点为当前节点中序遍历的前驱节点）；</span></span><br><span class="line"><span class="comment">2.1. 如果最右节点的右指针为空(right=null)，将最右节点的右指针指向当前节点，当前节点置为其左子节点；</span></span><br><span class="line"><span class="comment">2.2. 如果最右节点的右指针不为空，将最右节点右指针重新置为空(恢复树的原状)，输出当前节点，并将当前节点置为其右节点；</span></span><br><span class="line"><span class="comment">3. 重复1~2，直到当前节点为空。 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123; <span class="comment">// 3 -- 重复1-2,直至pre节点为空</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123; <span class="comment">// 2</span></span><br><span class="line">                <span class="comment">// pre 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span></span><br><span class="line">                pre = root.left; <span class="comment">// 记 pre 节点为 当前节点的左节点</span></span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right != root) &#123;</span><br><span class="line">                    pre = pre.right; <span class="comment">// pre节点指向当前节点左子树的最右节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="keyword">null</span>) &#123; <span class="comment">// 2.1 -- 对应条件 pre.right != null</span></span><br><span class="line">                    pre.right = root; <span class="comment">// 让 pre 的右指针指向 root</span></span><br><span class="line">                    root = root.left; <span class="comment">// 继续遍历左子树</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 2.2 -- 对应条件 pre.right != root, 说明左子树已经访问完，需断开链接</span></span><br><span class="line">                    list.add(root.val); <span class="comment">// 输出当前节点</span></span><br><span class="line">                    pre.right = <span class="keyword">null</span>; <span class="comment">// 恢复树的原状</span></span><br><span class="line">                    root = root.right; <span class="comment">// 指向当前节点的右节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 1 -- 如果没有左孩子，则直接访问右孩子</span></span><br><span class="line">                list.add(root.val); <span class="comment">// 输出当前节点</span></span><br><span class="line">                root = root.right; <span class="comment">// 指向当前节点的右节点, 当前节点返回了</span></span><br><span class="line">            &#125; <span class="comment">// 此时理解为当前节点移动到最左的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 个人版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre = root.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right != root) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="keyword">null</span>) &#123; <span class="comment">// -- 1</span></span><br><span class="line">                    pre.right = root;</span><br><span class="line">                    root = root.left;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 此处为循环链接当前节点左子树的最右节点为其前驱节点</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.right = <span class="keyword">null</span>; <span class="comment">// -- 3</span></span><br><span class="line">                    res.add(root.val); <span class="comment">// 根节点在遍历完左子树之后返回的途中存起来的</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此时理解为当前节点移动到最左的节点</span></span><br><span class="line">                res.add(root.val); <span class="comment">// -- 2</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h2><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：递归 -- 根左右</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">        res.add(root.val); <span class="comment">// 根</span></span><br><span class="line">        preorderTraversal(root.left); <span class="comment">// 左</span></span><br><span class="line">        preorderTraversal(root.right); <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法一：递归 -- 右左根，然后进行 翻转</span></span><br><span class="line"><span class="comment">// 这种翻转的思想，详情请见145.二叉树的后序遍历的注意事项</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">        preorderTraversal(root.right); <span class="comment">// 右</span></span><br><span class="line">        preorderTraversal(root.left); <span class="comment">// 左</span></span><br><span class="line">        res.add(<span class="number">0</span>, root.val); <span class="comment">// 根</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：迭代 --  1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                stack.push(root.right);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop(); <span class="comment">// 这种方式可能会迷糊为啥这样写</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：迭代 -- 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            root = root.right; <span class="comment">// 但是这种分开的方法，可以和中序遍历类比，容易理解和记忆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：迭代 -- 3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123; stack.offerLast(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pollLast();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123; stack.offerLast(node.right); &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123; stack.offerLast(node.left); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：迭代 -- 4 - 官方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="comment">// 这样写的好处是如果为空，不用新建栈</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三：morris遍历 -- 前序遍历 -- 前序遍历和中序遍历很相似，只有输出顺序发生变化。</span></span><br><span class="line"><span class="comment">/* 算法步骤：</span></span><br><span class="line"><span class="comment">1. 如果当前节点的左子节点为空时，输出当前节点，并将当前节点置为该节点的右子节点；</span></span><br><span class="line"><span class="comment">2. 如果当前节点的左子节点不为空，找到当前节点左子树的最右节点（该节点为当前节点中序遍历的前驱节点）；</span></span><br><span class="line"><span class="comment">2.1. 如果最右节点的右指针为空(right=null)，将最右节点的右指针指向当前节点，并输出当前节点（在此处输出），当前节点置为其左子节点；</span></span><br><span class="line"><span class="comment">2.2. 如果最右节点的右指针不为空，将最右节点右指针重新置为空(恢复树的原状)，并将当前节点置为其右节点；</span></span><br><span class="line"><span class="comment">3. 重复1~2，直到当前节点为空。 */</span></span><br><span class="line"><span class="comment">// 官方解答</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode p1 = root, p2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p2 = p1.left;</span><br><span class="line">            <span class="keyword">if</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p2.right != <span class="keyword">null</span> &amp;&amp; p2.right != p1) &#123;</span><br><span class="line">                    p2 = p2.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p2.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.add(p1.val);</span><br><span class="line">                    p2.right = p1;</span><br><span class="line">                    p1 = p1.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p2.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(p1.val);</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟前序遍历的官方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                root = root.right; <span class="comment">// 相同语句1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = root.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right != root) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.add(root.val);</span><br><span class="line">                    pre.right = root;</span><br><span class="line">                    root = root.left;</span><br><span class="line">                 <span class="comment">// continue; // 此处直接跳出此次循环，避免运行下边的那条公共语句 root = root.right;</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.right = <span class="keyword">null</span>;</span><br><span class="line">                    root = root.right; <span class="comment">// 相同语句2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">// root = root.right; // 均可放在此位置，但是上面三个出口会经过此处，但是有一处不需要此语句</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 个人解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre = root.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right != root) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="keyword">null</span>) &#123; <span class="comment">// -- 1</span></span><br><span class="line">                    res.add(root.val); <span class="comment">// 前序遍历在往左遍历的过程中就把根节点存起来了</span></span><br><span class="line">                    pre.right = root;</span><br><span class="line">                    root = root.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.right = <span class="keyword">null</span>; <span class="comment">// -- 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(root.val); <span class="comment">// -- 2</span></span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h2><p>给定一个二叉树，返回它的 <strong>后序</strong> 遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">        postorderTraversal(root.left);</span><br><span class="line">        postorderTraversal(root.right);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：迭代 -- 官方解答 -- 后序遍历的迭代方式要重点看</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123; <span class="comment">// 寻找最左边的节点</span></span><br><span class="line">                stack.push(root); <span class="comment">// 并把根节点扔进栈中</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop(); <span class="comment">// 找到了以后扔出来</span></span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span> || root.right == pre) &#123;</span><br><span class="line">                res.add(root.val); <span class="comment">// 这个节点的右子节点是空，或者是上一个节点（代表的是右）</span></span><br><span class="line">                pre = root; <span class="comment">// 就记住这个节点</span></span><br><span class="line">                root = <span class="keyword">null</span>; <span class="comment">// 节点置空</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此节点右边有节点，而且还不是上一个节点</span></span><br><span class="line">                stack.push(root); <span class="comment">// 把这个点重新压入栈</span></span><br><span class="line">                root = root.right; <span class="comment">// 把根节点指向右节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三：morris遍历 -- 不推荐版本 - 利用的是前序遍历，并进行两次翻转</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(<span class="number">0</span>, root.val);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = root.right;</span><br><span class="line">                <span class="keyword">while</span> (pre.left != <span class="keyword">null</span> &amp;&amp; pre.left != root) &#123;</span><br><span class="line">                    pre = pre.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pre.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.add(<span class="number">0</span>, root.val);</span><br><span class="line">                    pre.left = root;</span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.right = <span class="keyword">null</span>;</span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三：：morris遍历 -- 官方解答</span></span><br><span class="line"><span class="comment">/* 后序遍历规则总结如下：</span></span><br><span class="line"><span class="comment">1. 如果当前节点的左子节点为空时，则将其右子节点作为当前节点；</span></span><br><span class="line"><span class="comment">2. 如果当前节点的左子节点不为空，找到当前节点左子树的最右节点（该节点为当前节点中序遍历的前驱节点）；</span></span><br><span class="line"><span class="comment">2.1. 如果最右节点的右指针为空(right=null)，将最右节点的右指针指向当前节点，当前节点置为其左子节点；</span></span><br><span class="line"><span class="comment">2.2. 如果最右节点的右指针不为空，将最右节点右指针重新置为空(恢复树的原状)，倒序输出从当前节点的左子节点到该最右节点路径上的所有节点，并将当前节点置为其右节点；</span></span><br><span class="line"><span class="comment">3. 重复1~2，直到当前节点为空。 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">        TreeNode p1 = root, p2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p2 = p1.left;</span><br><span class="line">            <span class="keyword">if</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p2.right != <span class="keyword">null</span> &amp;&amp; p2.right != p1) &#123;</span><br><span class="line">                    p2 = p2.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p2.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p2.right = p1;</span><br><span class="line">                    p1 = p1.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p2.right = <span class="keyword">null</span>;</span><br><span class="line">                    addPath(res, p1.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为此方法是逆序输出当前节点的左子树最右侧，根节点最为当前节点 无法输出自身的最右侧，故只能循环结束单独输出</span></span><br><span class="line">        addPath(res, root); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPath</span><span class="params">(List&lt;Integer&gt; res, TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = res.size() - count, right = res.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = res.get(left);</span><br><span class="line">            res.set(left, res.get(right));</span><br><span class="line">            res.set(right, temp);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自写版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 用到的get/set方法多，这样快点儿</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>, temp = root;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre = root.left;</span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right != root) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pre.right = root;</span><br><span class="line">                    root = root.left; <span class="comment">// 此处为循环链接当前节点左子树的最右节点为其前驱节点</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre.right = <span class="keyword">null</span>;</span><br><span class="line">                    addPath(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        addPath(temp); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逆序添加二叉树的右侧边沿</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = res.size() - i, right = res.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 对称交换位置</span></span><br><span class="line">            <span class="keyword">int</span> temp = res.get(left);</span><br><span class="line">            res.set(left, res.get(right));</span><br><span class="line">            res.set(right, temp);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong>二叉树前中后序的递归版本属于easy题，而迭代版本通常是medium甚至是hard。</p>
<p>在做迭代版本之前，我建议大家先问问各类“遍历”算法的本质是什么？是最后输出的那一串有序的数字吗？数字的顺序是对的，遍历算法就是对的吗？</p>
<p>个人认为，以上问题的答案都应该是：否。“遍历”的本质是对内存的有序访问，失去了访问顺序，即便你用各种数据结构恢复了这个次序，遍历本身也显得毫无意义。常见的后序遍历写法中有一种已经出现在评论区了——它的思想也很简单，大家做过单词串翻转吗？</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> in  = <span class="string">&quot;it is a word&quot;</span></span><br><span class="line"><span class="keyword">String</span> out = <span class="string">&quot;word a is it&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个问题有一种很优雅的写法是先reverse(in)，然后再逐词翻转——“两次反转”，最后得到的就是正确顺序。</p>
<p>回到二叉树后序遍历，你也可以利用这种思想，利用双向链表的addFirst，对外部次序和内含次序进行同时翻转，同样会得到一种非常”优雅”的解法，结构简单明晰，甚至还有点好背（狗头）。但是，它并没有真正实现“遍历”——仔细看会发现，该算法其实在使用一种异构的前序遍历：“中-&gt;右-&gt;左”，而非传统意义上的“中-&gt;左-&gt;右”，而这种异构也正是他的第一次反转。而第二次反转就在输出序列上。</p>
<p>所以本质上，这是一个“前序遍历”，而不是所谓的“后序遍历”。只有当你的各个节点以“左-&gt;右-&gt;中”的次序依次出现在迭代的loop当中时，它才是真正的后序遍历，就像官解那样。贴个我个人的版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Set&lt;TreeNode&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span> &amp;&amp; seen.contains(s.peek())) &#123;</span><br><span class="line">                ans.add(s.pop().val);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                seen.add(s.peek());</span><br><span class="line">                root = s.peek().right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个方法有点骚，不过后序遍历确实比前序遍历算法和中序遍历算法难很多很多。</li>
<li>而这个性质犹如魔术般的数学公式，巧妙解答。先写出简单的前序遍历算法，然后稍微做一点点修改。</li>
<li><strong>不过本文不建议用这个方法</strong>，因为研究二叉树的性质应该是针对“节点的同类指针”（或者叫，左右子节点指针）性质为出发点，进行研究。因为二叉树毕竟是一种数据存储工具，我们应该研究它怎么存储数据，而不是研究怎么实现二叉树迭代遍历。即便是研究“二叉树迭代遍历”也应该是利用节点形式来实现。而不是前后遍历序列定义的规律。</li>
</ul>
<h2 id="589-N叉树的前序遍历"><a href="#589-N叉树的前序遍历" class="headerlink" title="589.N叉树的前序遍历"></a>589.N叉树的前序遍历</h2><p>给定一个 N 叉树，返回其节点值的前序遍历。</p>
<p>例如，给定一个 3叉树 :</p>
<p>返回其前序遍历: [1,3,5,6,2,4]。</p>
<p>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 方法一：递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">for</span> (Node node : root.children) &#123;</span><br><span class="line">            preorder(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：迭代1 -- 官方解答</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123; stack.offerLast(root); &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node node = stack.pollLast(); <span class="comment">//弹出父节点，并把值加入结果。</span></span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = node.children.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                stack.offerLast(node.children.get(i)); <span class="comment">//从右到左进站，出站就是左右。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590.N叉树的后序遍历"></a>590.N叉树的后序遍历</h2><p>给定一个 N 叉树，返回其节点值的<em>后序遍历</em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> res; &#125;</span><br><span class="line">        <span class="keyword">for</span> (Node node : root.children) &#123;</span><br><span class="line">            postorder(node);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：迭代 -- 官方解答</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> output; &#125;</span><br><span class="line">      	stack.add(root);</span><br><span class="line">      	<span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node node = stack.pollLast();</span><br><span class="line">        	output.addFirst(node.val);</span><br><span class="line">         	<span class="keyword">for</span> (Node item : node.children) &#123;</span><br><span class="line">                <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.add(item); </span><br><span class="line">                &#125; </span><br><span class="line">          	&#125;</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="559-N叉树的最大深度"><a href="#559-N叉树的最大深度" class="headerlink" title="559.N叉树的最大深度"></a>559.N叉树的最大深度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 方法一：递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node node : root.children) &#123;</span><br><span class="line">            tmp = maxDepth(node);</span><br><span class="line">            <span class="keyword">if</span> (max &lt; tmp) &#123; max = tmp; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：层序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        Deque&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans; i++) &#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (Node childNode : node.children) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (childNode != <span class="keyword">null</span>) &#123; queue.offer(childNode); &#125;</span><br><span class="line">                &#125; <span class="comment">// 此循环也可使用下面语句实现</span></span><br><span class="line">             <span class="comment">// queue.addAll(node.children);</span></span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="429-N叉树的层次遍历"><a href="#429-N叉树的层次遍历" class="headerlink" title="429.N叉树的层次遍历"></a>429.N叉树的层次遍历</h2><p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p>
<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, List&lt;Node&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;      </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                level.add(node.val);</span><br><span class="line">                queue.addAll(node.children);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="110-判断平衡二叉树"><a href="#110-判断平衡二叉树" class="headerlink" title="110.判断平衡二叉树"></a>110.判断平衡二叉树</h2><p>给定一个二叉树，判断它<strong>是否</strong>是高度平衡的二叉树。</p>
<p>本题中，一棵<strong>高度平衡二叉树定义</strong>为：</p>
<p>一个二叉树**<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1** 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：自底而顶的递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">recur</span><span class="params">(TreeNode root)</span> </span>&#123; <span class="comment">// 1.参数和返回值</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 2.终止条件</span></span><br><span class="line">        <span class="comment">// 3.单层递归逻辑</span></span><br><span class="line">        <span class="keyword">int</span> left = recur(root.left); <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = recur(root.right); <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> </span><br><span class="line">            ? Math.max(left, right) + <span class="number">1</span> </span><br><span class="line">            : -<span class="number">1</span>; <span class="comment">// 中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：自顶而底的递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(height(root.left) - height(root.right)) &lt;= <span class="number">1</span> </span><br><span class="line">            &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height(root.left), height(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h2><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在<strong>结构上相同</strong>，并且节点具有<strong>相同的值</strong>，则认为它们是相同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">     <span class="comment">/* return p.val == q.val </span></span><br><span class="line"><span class="comment">            &amp;&amp; isSameTree(p.left, q.left) </span></span><br><span class="line"><span class="comment">            &amp;&amp; isSameTree(p.right, q.right); */</span></span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">        <span class="comment">//var queue = new Queue&lt;TreeNode&gt;();</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(p);</span><br><span class="line">        queue.offer(q);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode u = queue.poll();</span><br><span class="line">            TreeNode v = queue.poll();</span><br><span class="line">            <span class="keyword">return</span> u.val == v.val </span><br><span class="line">            ? isSameTree(u.left, v.left) &amp;&amp; isSameTree(u.right, v.right)</span><br><span class="line">            : <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//  程序执行不到这</span></span><br><span class="line">     <span class="comment">// return false;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101-判断对称二叉树"><a href="#101-判断对称二叉树" class="headerlink" title="101.判断对称二叉树"></a>101.判断对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用递归函数，比较左节点，右节点</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归的终止条件是两个节点都为空</span></span><br><span class="line">        <span class="comment">//或者两个节点中有一个为空</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> || right==<span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">        <span class="comment">//再递归的比较 左节点的左孩子 和 右节点的右孩子</span></span><br><span class="line">        <span class="comment">//以及比较  左节点的右孩子 和 右节点的左孩子</span></span><br><span class="line">        <span class="comment">//以及比较两个节点的值是否相等</span></span><br><span class="line">        <span class="keyword">return</span> left.val == right.val </span><br><span class="line">            &amp;&amp; dfs(left.left,right.right) </span><br><span class="line">            &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：递归</span></span><br><span class="line"><span class="comment">/*  我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p指针和q指针一开始都指向这棵树的根，随后p右移时，q左移，p左移时，q右移。每次检查当前p和q节点的值是否相等，如果相等再判断左右子树是否对称。*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val </span><br><span class="line">            &amp;&amp; check(p.left, q.right) </span><br><span class="line">            &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三：迭代</span></span><br><span class="line"><span class="comment">/* 首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode u, TreeNode v)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        q.offer(u);</span><br><span class="line">        q.offer(v);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            u = q.poll();</span><br><span class="line">            v = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="keyword">null</span> &amp;&amp; v == <span class="keyword">null</span>) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> ((u == <span class="keyword">null</span> || v == <span class="keyword">null</span>) || (u.val != v.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q.offer(u.left);</span><br><span class="line">            q.offer(v.right);</span><br><span class="line"></span><br><span class="line">            q.offer(u.right);</span><br><span class="line">            q.offer(v.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>两种方法其实并无本质区别，方法二只是相当于方法一有一个根根节点，下边挂着两个根节点</p>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2><p><strong>ArrayList和LinkedList的大致区别</strong>如下:<br>1.<strong>ArrayList</strong>是实现了基于<strong>动态数组</strong>的数据结构，<strong>LinkedList</strong>基于<strong>链表</strong>的数据结构。<br>2.对于<strong>随机访问get和set</strong>，A<strong>rrayList优</strong>于LinkedList，因为LinkedList要移动指针。<br>3.对于<strong>新增和删除操作add和remove</strong>，<strong>LinkedList比较占优</strong>，因为ArrayList要移动数据。</p>
<p>102.二叉树的层序遍历<br>107.二叉树的层次遍历II<br>116.填充每个节点的下一个右侧节点指针<br>117.填充每个节点的下一个右侧节点指针II<br>199.二叉树的右视图<br>637.二叉树的层平均值<br>429.N叉树的前序遍历<br>515.在每个树行中找最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：广度优先遍历BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; outList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> outList; &#125; <span class="comment">// 根节点为null时，返回空列表</span></span><br><span class="line">        <span class="comment">// 根节点不为null时</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root); <span class="comment">// 根节点入队</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123; <span class="comment">// 队列空了结束循环</span></span><br><span class="line">            List&lt;Integer&gt; inList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> ans = queue.size(); <span class="comment">// 树的每层的节点数</span></span><br><span class="line">            <span class="keyword">while</span> (ans &gt; <span class="number">0</span>) &#123; <span class="comment">// 将同一层的节点放在同一个列表中</span></span><br><span class="line">                TreeNode node = queue.poll(); <span class="comment">// 抛出节点</span></span><br><span class="line">                inList.add(node.val); <span class="comment">// 添加节点的值</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123; queue.offer(node.left); &#125; <span class="comment">// 抛出节点的左节点入队</span></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123; queue.offer(node.right); &#125; <span class="comment">// 抛出节点的右节点入队</span></span><br><span class="line">                ans--; <span class="comment">// 没执行一次循环，减少一个本层节点个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            outList.add(inList); <span class="comment">// 将本层的节点值的列表加入总列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="103-二叉树的锯齿层次遍历"><a href="#103-二叉树的锯齿层次遍历" class="headerlink" title="103.二叉树的锯齿层次遍历"></a>103.二叉树的锯齿层次遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：广度优先遍历BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; outList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> outList; &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 用来判断奇偶行</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            List&lt;Integer&gt; inList = <span class="keyword">new</span> ArrayList&lt;&gt;(count);</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (ans % <span class="number">2</span> == <span class="number">0</span>) &#123; inList.add(node.val); &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123; inList.add(<span class="number">0</span>, node.val); &#125; <span class="comment">// 如果 index 没有传入实际参数，元素将追加至数组的最末尾。</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123; queue.offer(node.left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123; queue.offer(node.right); &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            outList.add(inList);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：深度优先遍历DFS</span></span><br><span class="line"><span class="comment">/* 该方法是将集合列表先建立好，到时候拉出相应的层的列表进行赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; outList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        travel(root, outList, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> outList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; outList, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//如果outList.size() &lt;= level说明下一层的集合还没创建，所以要先创建下一层的集合</span></span><br><span class="line">        <span class="keyword">if</span> (outList.size() &lt;= level) &#123;</span><br><span class="line">            List&lt;Integer&gt; newLevel = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            outList.add(newLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历到第几层我们就操作第几层的数据</span></span><br><span class="line">        List&lt;Integer&gt; inList = outList.get(level);</span><br><span class="line">        <span class="comment">//这里默认根节点是第0层，偶数层相当于从左往右遍历，</span></span><br><span class="line">        <span class="comment">// 所以要添加到集合的末尾，如果是奇数层相当于从右往左遍历，</span></span><br><span class="line">        <span class="comment">// 要把数据添加到集合的开头</span></span><br><span class="line">        <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            inList.add(root.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            inList.add(<span class="number">0</span>, root.val);</span><br><span class="line">        <span class="comment">//分别遍历左右两个子节点，到下一层了，所以层数要加1</span></span><br><span class="line">        travel(root.left, outList, level + <span class="number">1</span>);</span><br><span class="line">        travel(root.right, outList, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="107-二叉树的层序遍历II"><a href="#107-二叉树的层序遍历II" class="headerlink" title="107.二叉树的层序遍历II"></a>107.二叉树的层序遍历II</h2><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：广度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; outList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> outList; &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; inList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> ans = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (ans &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                inList.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123; queue.offer(node.left); &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123; queue.offer(node.right); &#125;</span><br><span class="line">                ans--;</span><br><span class="line">            &#125;</span><br><span class="line">            outList.add(<span class="number">0</span>, inList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：深度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; outList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> outList; &#125; <span class="comment">// 根节点为空时，直接返回空列表</span></span><br><span class="line">        dfs(root, outList, <span class="number">0</span>); <span class="comment">// 进行正序二叉树层序遍历</span></span><br><span class="line">        Collections.reverse(outList); <span class="comment">// 翻转列表</span></span><br><span class="line">        <span class="keyword">return</span> outList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; outList, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span>; &#125;  <span class="comment">// 根节点为空，void返回值类型，使用return终止函数</span></span><br><span class="line">        <span class="keyword">if</span> (outList.size() &lt;= level) &#123; <span class="comment">// 外部数组内存的内部数组数量不够，进行扩容</span></span><br><span class="line">            List&lt;Integer&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            outList.add(newList);</span><br><span class="line">        &#125;</span><br><span class="line">        outList.get(level).add(root.val); <span class="comment">// 给相应层数添加根节点的值</span></span><br><span class="line">        dfs(root.left, outList, level + <span class="number">1</span>); <span class="comment">// 递归左子树</span></span><br><span class="line">        dfs(root.right, outList, level + <span class="number">1</span>); <span class="comment">// 递归右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   </span><br><span class="line">        <span class="comment">// null节点不参与比较</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// null节点不参与比较</span></span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.min(minDepth(root.left), minDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法一：(2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> left = minDepth(root.left); <span class="comment">// 左 ：对左子树进行最小深度查找</span></span><br><span class="line">        <span class="keyword">int</span> right = minDepth(root.right); <span class="comment">// 右 ：对右子树进行最小深度查找</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> || root.right == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="comment">// 如果左子树和右子树至少有一个为null，left和right必有一项为0(因为)</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">/*return root.left == null || root.right == null </span></span><br><span class="line"><span class="comment">        	? Math.max(left, right) + 1 </span></span><br><span class="line"><span class="comment">        	: Math.min(left, right) + 1;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：深度优先遍历(DFS)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123; min = Math.min(minDepth(root.left), min); &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123; min = Math.min(minDepth(root.right), min); &#125;</span><br><span class="line">        <span class="keyword">return</span> min_depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：广度优先遍历(BFS)</span></span><br><span class="line"><span class="comment">/* 当我们找到一个叶子节点时，直接返回这个叶子节点的深度。广度优先搜索的性质保证了最先搜索到的叶子节点的深度一定最小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QueueNode</span> </span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QueueNode</span><span class="params">(TreeNode node, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        Queue&lt;QueueNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;QueueNode&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> QueueNode(root, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            QueueNode nodeDepth = queue.poll();</span><br><span class="line">            TreeNode node = nodeDepth.node;</span><br><span class="line">            <span class="keyword">int</span> depth = nodeDepth.depth;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> QueueNode(node.left, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> QueueNode(node.right, depth + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回任何整数都可以，因为程序执行不到这</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：官方解释使用深度优先搜索(DFS) 和广度优先搜索(BFS) </p>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：递归</span></span><br><span class="line"><span class="comment">/* 因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件：当树为空时结束递归，并返回当前深度0</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="comment">//root的左、右子树的最大深度</span></span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">        <span class="comment">//返回的是左右子树的最大深度+1</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：广度优先搜索(BFS) -- 层次遍历</span></span><br><span class="line"><span class="comment">/* 此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量ans来维护拓展的次数，该二叉树的最大深度即ans。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root); <span class="comment">// 根节点入队</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123; <span class="comment">// 直到队列为空退出循环</span></span><br><span class="line">            <span class="keyword">int</span> size = queue.size(); <span class="comment">// 队列中元素</span></span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll(); <span class="comment">// 根节点出队</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123; </span><br><span class="line">                    queue.offer(node.left); <span class="comment">// 左子节点入队</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right); <span class="comment">// 右子节点入队</span></span><br><span class="line">                &#125;</span><br><span class="line">                size--; <span class="comment">// 直到这层根节点全部出队列</span></span><br><span class="line">            &#125; <span class="comment">// 注意此循环 与 226.翻转二叉树交换左右子树 的区别：循环是为了区分队列中哪些节点是在同一层的</span></span><br><span class="line">            ans++; <span class="comment">// 将此层数进行记录</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三：重要的是思路</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="comment">//stack记录的是节点，而level中的元素和stack中的元素</span></span><br><span class="line">        <span class="comment">//是同时入栈同时出栈，并且level记录的是节点在第几层</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; level = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        level.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//stack中的元素和level中的元素同时出栈</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> temp = level.pop();</span><br><span class="line">            max = Math.max(temp, max);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//同时入栈</span></span><br><span class="line">                stack.push(node.left);</span><br><span class="line">                level.push(temp + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//同时入栈</span></span><br><span class="line">                stack.push(node.right);</span><br><span class="line">                level.push(temp + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h2><p>翻转一棵二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="comment">// 自顶而底</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123; <span class="keyword">return</span> root; &#125;</span><br><span class="line">        <span class="comment">// 先交换</span></span><br><span class="line">        TreeNode temp=root.left;</span><br><span class="line">        root.left=root.right;</span><br><span class="line">        root.right=temp;</span><br><span class="line">        <span class="comment">// 再递归</span></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：后序遍历</span></span><br><span class="line"><span class="comment">/* 这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子结点先开始翻转。如果当前遍历到的节点root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以root 为根节点的整棵子树的翻转。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125; <span class="comment">// 递归函数的终止条件，节点为空时返回 </span></span><br><span class="line">        <span class="comment">// 后序遍历：自底而顶 </span></span><br><span class="line">        TreeNode leftTemp = invertTree(root.left); <span class="comment">// 左</span></span><br><span class="line">        TreeNode rightTemp = invertTree(root.right); <span class="comment">// 右</span></span><br><span class="line">        root.left = rightTemp; <span class="comment">// 根 (此句跟上一句可合并为一句，见后面注释)</span></span><br><span class="line">        root.right = leftTemp;</span><br><span class="line">     <span class="comment">/* TreeNode t1 = invertTree(root.left); //左</span></span><br><span class="line"><span class="comment">        root.left = invertTree(root.right); // 右</span></span><br><span class="line"><span class="comment">        root.right = t1; // 根 */</span> </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三：前序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125; <span class="comment">// 递归函数的终止条件，节点为空时返回</span></span><br><span class="line">        <span class="comment">// 前序遍历：自顶而底</span></span><br><span class="line">        TreeNode rightTemp = root.right; <span class="comment">// 根</span></span><br><span class="line">        root.right = invertTree(root.left); <span class="comment">// 左</span></span><br><span class="line">        root.left = invertTree(rightTemp); <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法四：中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 递归函数的终止条件，节点为空时返回</span></span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        invertTree(root.left); <span class="comment">// 递归找到左节点</span></span><br><span class="line">        TreeNode rightNode= root.right; <span class="comment">// 保存右节点</span></span><br><span class="line">        root.right = root.left;</span><br><span class="line">        root.left = rightNode;</span><br><span class="line">        <span class="comment">// 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left</span></span><br><span class="line">        invertTree(root.left); </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法五：层次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 层次遍历--直接左右交换即可</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root); <span class="comment">// 根节点入队</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123; <span class="comment">// 直到队列为空退出循环</span></span><br><span class="line">            TreeNode node = queue.poll(); <span class="comment">// 根节点出队</span></span><br><span class="line">            <span class="comment">// 注意此交换 与 104.二叉树的最大深度 的区别：因为交换节点，每一个节点都需要交换，不需要在乎哪些节点是在同一层上的</span></span><br><span class="line">            TreeNode rightTree = node.right; <span class="comment">// 将根节点左右互换</span></span><br><span class="line">            node.right = node.left;</span><br><span class="line">            node.left = rightTree; </span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123; <span class="comment">// 子节点入队</span></span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123; <span class="comment">// 子节点入队</span></span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="105-从前序与中序遍历序列构建二叉树"><a href="#105-从前序与中序遍历序列构建二叉树" class="headerlink" title="105.从前序与中序遍历序列构建二叉树"></a>105.从前序与中序遍历序列构建二叉树</h2><p>根据一棵树的<strong>前序</strong>遍历与<strong>中序</strong>遍历构造二叉树。</p>
<p><strong>注意：</strong>你可以<strong>假设树中没有重复</strong>的元素。本文方法只适用于 “无重复节点值” 的二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：递归 —— 官方版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap; <span class="comment">// 在外面设置哈希表的原因是可以当全局变量，递归时不用带着这个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">myBuildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preorder_left, <span class="keyword">int</span> preorder_right, <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 区间不构成区间，是递归的终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">        <span class="keyword">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">        <span class="keyword">int</span> inorder_root = indexMap.get(preorder[preorder_root]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把根节点建立出来</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">        <span class="keyword">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">        root.left = myBuildTree(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length;</span><br><span class="line">        <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myBuildTree(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法一：递归 —— 自己书写的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = inorder.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, len - <span class="number">1</span>, inorder, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preStart &gt; preEnd) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125; <span class="comment">// 当数值不构成区间时，退出递归</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preStart]; <span class="comment">// 找到根节点的值</span></span><br><span class="line">        <span class="keyword">int</span> rootInIndex = map.get(rootVal); <span class="comment">// 找到根节点在中序遍历中的索引位置</span></span><br><span class="line">        <span class="keyword">int</span> leftTreeLen = rootInIndex - inStart; <span class="comment">// 计算左子树的长度</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal); <span class="comment">// 创建根节点</span></span><br><span class="line">        <span class="comment">// 递归创建根节点的左子树和右子树</span></span><br><span class="line">        root.left = buildTree(preorder, preStart + <span class="number">1</span>, preStart + leftTreeLen, inorder, inStart, rootInIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preorder, preStart + leftTreeLen + <span class="number">1</span>, preEnd, inorder, rootInIndex + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">int</span> inorderIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preorderVal = preorder[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inorderIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(preorderVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="106-从中序与后序遍历序列构建二叉树"><a href="#106-从中序与后序遍历序列构建二叉树" class="headerlink" title="106.从中序与后序遍历序列构建二叉树"></a>106.从中序与后序遍历序列构建二叉树</h2><p>根据一棵树的<strong>中序</strong>遍历与<strong>后序</strong>遍历构造二叉树。</p>
<p><strong>注意：</strong>你可以<strong>假设树中没有重复</strong>的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = inorder.length;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(postorder, <span class="number">0</span>, len - <span class="number">1</span>, inorder, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postStart &gt; postEnd) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> rootVal = postorder[postEnd];</span><br><span class="line">        <span class="keyword">int</span> rootInIndex = map.get(rootVal);</span><br><span class="line">        <span class="keyword">int</span> rightLen = inEnd - rootInIndex;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        root.left = buildTree(postorder, postStart, postEnd - rightLen - <span class="number">1</span>, inorder, inStart, rootInIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(postorder, postEnd - rightLen, postEnd - <span class="number">1</span>, inorder, rootInIndex + <span class="number">1</span>, inEnd);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder == <span class="keyword">null</span> || postorder.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postorder.length - <span class="number">1</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">int</span> inorderIndex = inorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> postorderVal = postorder[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.val != inorder[inorderIndex]) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(postorderVal);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) &#123;</span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    inorderIndex--;</span><br><span class="line">                &#125;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(postorderVal);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，<strong>判断该树中是否存在</strong> 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p><strong>注意</strong>到本题的要求是，询问是否有从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和。<strong>核心思想</strong>是对树进行一次<strong>遍历</strong>，在<strong>遍历时记录</strong>从根节点到当前节点的<strong>路径和</strong>，以<strong>防止重复</strong>计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：广度优先遍历</span></span><br><span class="line"><span class="comment">// 首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125; <span class="comment">// 如果节点为空，返回false</span></span><br><span class="line">        <span class="comment">// 接下来的情况是节点不为空</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queNode = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); <span class="comment">// 用来存节点</span></span><br><span class="line">        Queue&lt;Integer&gt; queVal = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(); <span class="comment">// 用来存遍历到当前节点时的路径和，可以做到唯一不重复</span></span><br><span class="line">        queNode.offer(root);</span><br><span class="line">        queVal.offer(root.val); <span class="comment">// 这两句是往队列中存储节点和当前路径和</span></span><br><span class="line">        <span class="keyword">while</span> (!queNode.isEmpty()) &#123; <span class="comment">// 节点队列只要不为空，就一直执行循环</span></span><br><span class="line">            TreeNode node = queNode.poll();</span><br><span class="line">            <span class="keyword">int</span> nodeVal = queVal.poll(); <span class="comment">// 这两句是队列中的节点和值扔出来</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123; <span class="comment">// 发现了叶子节点</span></span><br><span class="line">                <span class="keyword">if</span> (nodeVal == targetSum) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125; <span class="comment">// 发现正好是</span></span><br><span class="line">              <span class="comment">//continue; // 这句话就算是不加，也不会运行下边的语句 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123; <span class="comment">// 如果左节点不是空的，就进行左节点存储</span></span><br><span class="line">                queNode.offer(node.left);</span><br><span class="line">                queVal.offer(node.left.val + nodeVal);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123; <span class="comment">// 如果右节点不是空的，就进行右节点存储</span></span><br><span class="line">                queNode.offer(node.right);</span><br><span class="line">                queVal.offer(node.right.val + nodeVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：深度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125; <span class="comment">// 如果节点为空，返回false</span></span><br><span class="line">        targetSum -= root.val; <span class="comment">// 将目标值减去当前节点值</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123; <span class="comment">// 判断此节点是否叶子节点</span></span><br><span class="line">            <span class="keyword">return</span> targetSum == <span class="number">0</span>; <span class="comment">// 目标值正好减为 0 </span></span><br><span class="line">        &#125; <span class="comment">// 若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="113-路径总和II"><a href="#113-路径总和II" class="headerlink" title="113.路径总和II"></a>113.路径总和II</h2><p>给定一个二叉树和一个目标和，<strong>找到所有</strong>从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：深度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; outList = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">   	<span class="keyword">private</span> Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> outList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        path.offerLast(root.val);</span><br><span class="line">        targetSum -= root.val; <span class="comment">// 将目标值减掉此根节点的值，成为子节点目标值</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123; <span class="comment">// 判断此节点是叶子节点且目标值减为 0</span></span><br><span class="line">            outList.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(path)); <span class="comment">// 向最终返回值中添加当前路径</span></span><br><span class="line">        &#125; <span class="comment">// 之所以要 new，因为路径存储时公用的，后边还要进行删除更换</span></span><br><span class="line">        dfs(root.left, targetSum); <span class="comment">// 左递归</span></span><br><span class="line">        dfs(root.right, targetSum); <span class="comment">// 右递归</span></span><br><span class="line">        path.pollLast(); <span class="comment">// 将当前节点，从后边扔掉，换新的节点进行遍历了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：广度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置全局变量</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; outList = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 存储最终返回值</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;TreeNode, TreeNode&gt; pathMap = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 通过键值对的形式存储路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getPath</span><span class="params">(TreeNode node)</span> </span>&#123; <span class="comment">// 得到路径</span></span><br><span class="line">        List&lt;Integer&gt; inList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inList.add(<span class="number">0</span>, node.val);</span><br><span class="line">            node = pathMap.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">        outList.add(inList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> outList; &#125; <span class="comment">// 如果节点为空，将返回最终值</span></span><br><span class="line">        <span class="comment">// 接下来的情况是节点不为空</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queNode = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">        Queue&lt;Integer&gt; queVal = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        pathMap.put(root, <span class="keyword">null</span>); <span class="comment">// 将根节点存入路径的hashMap中</span></span><br><span class="line">        queNode.offer(root);</span><br><span class="line">        queVal.offer(root.val); <span class="comment">// 这两句是将节点和路径和扔进队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queNode.isEmpty()) &#123; <span class="comment">// 节点队列不空，就一直执行循环</span></span><br><span class="line">            TreeNode node = queNode.poll();</span><br><span class="line">            <span class="keyword">int</span> nodeVal = queVal.poll(); <span class="comment">// 这两句是将节点值扔出来</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123; <span class="comment">// 判断是否为叶子节点</span></span><br><span class="line">                <span class="keyword">if</span> (nodeVal == targetSum) &#123; getPath(node); &#125; <span class="comment">// 发现正好是，得到路径</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123; <span class="comment">// 如果左节点不空</span></span><br><span class="line">                pathMap.put(node.left, node); <span class="comment">// 存路径</span></span><br><span class="line">                queNode.offer(node.left); <span class="comment">// 存节点</span></span><br><span class="line">                queVal.offer(node.left.val + nodeVal); <span class="comment">// 存路径和</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123; <span class="comment">// 同上</span></span><br><span class="line">                pathMap.put(node.right, node);</span><br><span class="line">                queNode.offer(node.right);</span><br><span class="line">                queVal.offer(node.right.val + nodeVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outList; <span class="comment">// 输出返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二叉搜索树（二叉排序树、二叉查找树）"><a href="#二叉搜索树（二叉排序树、二叉查找树）" class="headerlink" title="二叉搜索树（二叉排序树、二叉查找树）"></a>二叉搜索树（二叉排序树、二叉查找树）</h1><p><strong>定义：</strong>它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则<strong>左</strong>子树上所有结点的值<strong>均小于</strong>它的根节点的值； 若它的右子树不空，则<strong>右</strong>子树上所有结点的值<strong>均大于</strong>它的根结点的值； 它的左、右子树也分别为二叉排序树。二叉搜索树作为一种<strong>经典的数据结构</strong>，它既有<strong>链表的快速插入与删除</strong>操作的特点，又有<strong>数组快速查找</strong>的优势；所以应用十分广泛，例如在<strong>文件系统和数据库系统</strong>一般会采用这种数据结构进行高效率的排序与检索操作。</p>
<p><strong>算法层面：</strong>二叉排序树的<strong>操作</strong>主要有：</p>
<p>1.查找：<strong>递归查找</strong>是否存在key。</p>
<p>2.<strong>插入</strong>：原树中不存在key，插入key返回true，否则返回false。</p>
<p>3.构造：<strong>循环的插入</strong>操作。(前三项<strong>环环相扣</strong>，<strong>插入需要查找，构造需要插入</strong>，学一构造，前者皆通)</p>
<p>4.删除：（1）<strong>叶子</strong>节点：<strong>直接删除</strong>，不影响原树。</p>
<p>（2）<strong>仅仅</strong>有左或右子树的节点：<strong>子承父业</strong>，节点删除后，将它的左子树或右子树整个移动到删除节点的位置就可以。</p>
<p>（3）<strong>既有</strong>左又有右子树的节点：<strong>后继孩子节点继承</strong>，找到须要删除的节点p的直接前驱或者直接后继s，用s来替换节点p，然后再删除节点s。</p>
<h2 id="递归与回溯的区别"><a href="#递归与回溯的区别" class="headerlink" title="递归与回溯的区别"></a>递归与回溯的区别</h2><p><strong>递归</strong>是一种<strong>算法结构</strong>，一个递归就是在函数中调用函数本身来解决问题。<strong>回溯</strong>是一种<strong>算法思想</strong>，它是用递归实现的。回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”，意思就是对已经知道错误的结果没必要再枚举接下来的答案了。</p>
<p>用一个<strong>比较通俗</strong>的说法来解释<strong>递归和回溯</strong>：<br>我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。<strong>尝试的过程就是一个函数。</strong><br>我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以<strong>我们需要在上一次尝试结果的基础上，再做一次尝试</strong>，即<strong>在函数内部再调用一次函数</strong>，这就是<strong>递归</strong>的<strong>过程</strong>。<br>这样重复了若干次之后，发现<strong>这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路</strong>，这就是<strong>回溯</strong>的<strong>思想</strong>。</p>
<h2 id="108-有序数组转换二叉排序树"><a href="#108-有序数组转换二叉排序树" class="headerlink" title="108.有序数组转换二叉排序树"></a>108.有序数组转换二叉排序树</h2><p>将一个按照<strong>升序排列</strong>的有序<strong>数组</strong>，转换为一棵<strong>高度平衡</strong>二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 方法一：递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">bst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>; <span class="comment">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class="line">        <span class="comment">// int mid = (left + right + 1) / 2; // 总是选择中间位置右边的数字作为根节点</span></span><br><span class="line">        <span class="comment">// int mid = (left + right + rand.nextInt(2)) / 2; // 选择任意一个中间位置数字作为根节点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = bst(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = bst(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="109-有序链表转换二叉排序树"><a href="#109-有序链表转换二叉排序树" class="headerlink" title="109.有序链表转换二叉排序树"></a>109.有序链表转换二叉排序树</h2><p>给定一个<strong>单链表</strong>，其中的元素按<strong>升序排序</strong>，将其转换为<strong>高度平衡</strong>的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 这类题的重点时寻找 中位点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一：将链表变为数组，数组范围表示最好使用闭区间，而链表只用左闭右开区间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：分治，重点是如何找出链表的中位点，链表范围表示使用左闭右开区间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sortedListToBST(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode start, ListNode end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        ListNode midNode = getMidNode(start, end);</span><br><span class="line">        <span class="keyword">int</span> rootVal = midNode.val;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        root.left = sortedListToBST(start, midNode);</span><br><span class="line">        root.right = sortedListToBST(midNode.next, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">getMidNode</span><span class="params">(ListNode start, ListNode end)</span> </span>&#123; <span class="comment">// 寻找链表中位点</span></span><br><span class="line">        ListNode fast = start;</span><br><span class="line">        ListNode slow = start;</span><br><span class="line">        <span class="keyword">while</span> (fast != end &amp;&amp; fast.next != end) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法三：分治 + 中序遍历优化</span></span><br><span class="line"><span class="comment">/* 时间复杂度的瓶颈在于寻找中位数节点。由于构造出的二叉搜索树的中序遍历结果就是链表本身，因此我们可以将分治和中序遍历结合起来，减少时间复杂度。这道题提供了非常好的思路：巧妙选择遍历方案避免链表不能随机访问的缺点。 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode globalTemp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        globalTemp = head;</span><br><span class="line">        <span class="keyword">int</span> len = getLength(globalTemp);</span><br><span class="line">        <span class="keyword">return</span> sortedListToBST(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>; <span class="comment">// 得到链表的长度</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = head.next; </span><br><span class="line">            length++; <span class="comment">// 累加的这个地方得注意，想不明白找几个数试试</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(globalTemp.val);</span><br><span class="line">        root.left = sortedListToBST(start, mid - <span class="number">1</span>); <span class="comment">// 找到左节点</span></span><br><span class="line">        root.val = globalTemp.val; <span class="comment">// 根节点赋值</span></span><br><span class="line">        globalTemp = globalTemp.next; <span class="comment">// 将指针指向下一个链表节点</span></span><br><span class="line">        root.right = sortedListToBST(mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：<strong>105、106、108、109</strong>，均有通过<strong>双指针索引</strong>方法进行递归函数的设计，其中<strong>数值索引为闭区间，链表节点索引为开区间</strong>。这类题的重点时寻找 <strong>中位点</strong>。</p>
<h2 id="096-不同的二叉搜索树"><a href="#096-不同的二叉搜索树" class="headerlink" title="096.不同的二叉搜索树"></a>096.不同的二叉搜索树</h2><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<p>解题思路<br><strong>标签：动态规划</strong></p>
<p>假设 n 个节点存在二叉排序树的个数是 G (n)，令 f(i) 为以 i 为根的二叉搜索树的个数，则<br>$$<br>G(n) = f(1) + f(2) + f(3) + f(4) + … + f(n)<br>$$<br>当 i 为根节点时，其左子树节点个数为 i-1 个，右子树节点为 n-i，则<br>$$<br>f(i) = G(i-1)*G(n-i)<br>$$<br><img src="https://gitee.com/edg7928/my-images/raw/master/96_fig1.png" alt="fig1"><br>综合两个公式可以得到 <strong>卡特兰数</strong> 公式<br>$$<br>G(n) = G(0)*G(n-1)+G(1)*G(n-2)+…+G(n-1)*G(0)<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/edg7928/my-images/raw/master/image-20210219123811862.png" alt="image-20210219123811862"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提示：我们在这里需要用 long 类型防止计算过程中的溢出</span></span><br><span class="line">        <span class="keyword">long</span> C = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            C = C * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="095-不同的二叉搜索树II"><a href="#095-不同的二叉搜索树II" class="headerlink" title="095.不同的二叉搜索树II"></a>095.不同的二叉搜索树II</h2><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;(); &#125;</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            allTrees.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举可行根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode left : leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode right : rightTrees) &#123;</span><br><span class="line">                    TreeNode currTree = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    currTree.left = left;</span><br><span class="line">                    currTree.right = right;</span><br><span class="line">                    allTrees.add(currTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
</search>
